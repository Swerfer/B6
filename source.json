{"language":"Solidity","sources":{"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"@openzeppelin/contracts/utils/Create2.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | â†“ ptr ...  â†“ ptr + 0x0B (start) ...  â†“ ptr + 0x20 ...  â†“ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"},"@openzeppelin/contracts/utils/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"},"@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"contracts/MissionFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// #region Introduction\r\n/**\r\n * Â© 2025 Be Brave Be Bold Be Bankedâ„¢ | B6 Labsâ„¢ â€“ Swerfer\r\n * All rights reserved.\r\n *\r\n * @title   Be Brave Be Bold Be Bankedâ„¢ â€“ Mission & Factory Architecture\r\n * @author  B6 Labsâ„¢ â€“ Swerfer\r\n *\r\n * @notice\r\n * ## ðŸ§© Components (this file)\r\n * - **MissionFactory** â€” deploys EIP-1167 clones of `Mission`, tracks status,\r\n *   enforces weekly/monthly enrollment limits, routes economics, and manages\r\n *   a per-type reserve of leftover funds.\r\n * - **Mission** â€” a time-boxed game with linear, monotonic payouts and\r\n *   cooldowns between rounds.\r\n *\r\n * ## ðŸ”Œ External dependencies\r\n * OpenZeppelin `Ownable`, `ReentrancyGuard`, `Clones`, and `Strings`.\r\n *\r\n * ## ðŸ” Lifecycle & real-time status\r\n * The on-chain lifecycle is expressed by `enum Status` and computed on demand:\r\n * `Pending â†’ Enrolling â†’ Arming â†’ Active â†” Paused â†’ (PartlySuccess | Success | Failed)`.\r\n * - **Pending**: clone exists, before enrollment opens.\r\n * - **Enrolling**: `enrollmentStart..enrollmentEnd`. Players pay `enrollmentAmount` once.\r\n * - **Arming**: minimum players reached, waiting for `missionStart`.\r\n * - **Active**: `missionStart..missionEnd`. On each successful round call, one distinct player wins.\r\n * - **Paused**: enforced cooldown after a round; duration is per-mission.\r\n * - **PartlySuccess/Success/Failed**: terminal outcomes used for settlement paths.\r\n *\r\n * ## ðŸ‘¥ Enrollment limits (anti-addiction)\r\n * The factory enforces global weekly/monthly limits per address via `canEnroll()` and\r\n * records enrollments with `recordEnrollment()`. Helper views:\r\n * `secondsTillWeeklySlot()` and `secondsTillMonthlySlot()`.\r\n *\r\n * ## ðŸ’° Payout model (monotonic and time-based)\r\n * Let `progress = (now - missionStart) / (missionEnd - missionStart)` (scaled).\r\n * The **cumulative entitlement** is `croStart * progress`. The round payout equals\r\n * `entitlement - paidSoFar`, clamped to `croCurrent`. A player may win **once** per mission.\r\n *\r\n * ## â± Cooldowns\r\n * Two per-mission parameters are provided during creation:\r\n * - `roundPauseDuration` â€” cooldown after non-final rounds (seconds).\r\n * - `lastRoundPauseDuration` â€” cooldown before the final round (seconds).\r\n * **Note:** there are **no enforced on-chain defaults**; any â€œ1 minuteâ€ defaults are a UI choice.\r\n *\r\n * ## ðŸ”’ InviteOnly secret enrollment\r\n * InviteOnly missions verify a **private commitment** `_enrollSecretHash`,\r\n * computed off-chain as `keccak256(passphrase, enrollmentStart)`. The hash is stored\r\n * **privately** on the mission (not in public `MissionData`) and checked in\r\n * `enrollPlayerWithSecret(passphrase)`.\r\n *\r\n * ## ðŸ¦ Economics & settlement\r\n * After refunds are secured/reserved:\r\n * - **InviteOnly**: **100%** of leftover goes to the **factory owner**\r\n * - **UserMission**: **50%** to the factory owner; **50%** to the **creator**\r\n * - **Other types**: **25%** to the factory owner; **75%** to the **per-type reserve**\r\n *   `reservedFunds[missionType]`.\r\n * On creating a new mission, the factory **optionally boosts** it with\r\n * `allocation = reservedFunds[type] / 4`, sent to the mission via `increasePot()`.\r\n *\r\n * ## ðŸ§¾ Ownership & authorization\r\n * The factory owner can add/remove authorized helpers and manage a two-step ownership\r\n * transfer (`proposeOwnershipTransfer` / `confirmOwnershipTransfer`). Sensitive functions\r\n * are protected by `onlyOwner`, `onlyOwnerOrAuthorized`, and `nonReentrant` where applicable.\r\n *\r\n * ## ðŸ§­ What to look for in the code\r\n * - Factory: clone deployment, reserve accounting, enrollment limit bookkeeping,\r\n *   rich getters for dApps/indexers.\r\n * - Mission: initialize, enroll (normal & secret), round calling, cooldown checks,\r\n *   refunds, settlement routing, and detailed views for indexers.\r\n */\r\n// #endregion Introduction\r\n\r\n\r\npragma solidity ^0.8.30;\r\n\r\n\r\n// #region Imports\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// #endregion\r\n\r\n\r\n\r\n\r\n\r\n// #region Global Enums\r\n/**\r\n * @dev Enum to represent the type of mission.\r\n * The mission can be one of several types: Custom, Hourly, QuarterDaily, BiDaily, Daily, Weekly, or Monthly.\r\n * The default use for each type is defined in the comments but is set in the dApp UI and can vary.\r\n */\r\nenum MissionType {\r\n    Custom,         // No default use, completely custom\r\n    Hourly,         // Default use:  1 day  enrollment, 1 hour arming,  1 hour  rounds\r\n    QuarterDaily,   // Default use:  1 day  enrollment, 1 hour arming,  6 hours rounds\r\n    BiDaily,        // Default use:  1 day  enrollment, 1 hour arming, 12 hours rounds\r\n    Daily,          // Default use:  1 day  enrollment, 1 hour arming, 24 hours rounds\r\n    Weekly,         // Default use:  1 week enrollment, 1 hour arming,  7 days  rounds\r\n    Monthly,        // Default use:  1 week enrollment, 1 hour arming, 30 days  rounds\r\n    InviteOnly,     // Default use:  Custom enrollment, custom arming,   custom rounds\r\n    UserMission     // Default use:  Custom enrollment, custom arming,   custom rounds\r\n}\r\n\r\n/**\r\n * @dev Enum to represent the status of a mission.\r\n * The mission can be in one of several states: Pending, Enrolling, Active, Paused, Ended, or Failed.\r\n */\r\nenum Status     {\r\n    Pending,        // Mission is created but not yet enrolling\r\n    Enrolling,      // Mission is open for enrollment, waiting for players to join\r\n    Arming,         // Mission is armed and ready to start\r\n    Active,         // Mission is currently active and players can participate\r\n    Paused,         // Mission is paused, no further actions can be taken\r\n    PartlySuccess,  // Mission has ended with some players winning, but not all rounds were claimed\r\n    Success,        // Mission has ended successfully, all rounds were claimed\r\n    Failed          // Mission has failed, no players won or not enough players enrolled\r\n}\r\n\r\n/**\r\n * @dev Enum to represent the enrollment limits for a mission.\r\n * The limits can be None, Weekly, or Monthly.\r\n */\r\nenum Limit      { \r\n    None,       // No limit breached\r\n    Weekly,     // Weekly limit breached\r\n    Monthly     // Monthly limit breached\r\n}\r\n// #endregion\r\n\r\n\r\n\r\n\r\n\r\n// #region Contr. MissionFactory\r\ncontract MissionFactory is Ownable, ReentrancyGuard {\r\n    using Clones    for address;\r\n\r\n\r\n\r\n    // #region Events\r\n    /** \r\n     * @dev Events emitted by the MissionFactory contract.\r\n     * These events are used to log important actions and state changes within the contract.\r\n     */\r\n    event MissionCreated(\r\n        address indexed mission,\r\n        string          name,\r\n        MissionType     missionType,\r\n        uint256         enrollmentStart,\r\n        uint256         enrollmentEnd,\r\n        uint8           minPlayers,\r\n        uint8           maxPlayers,\r\n        uint8           roundPauseDuration,\r\n        uint8           lastRoundPauseDuration,\r\n        uint256         enrollmentAmount,\r\n        uint256         missionStart,\r\n        uint256         missionEnd,\r\n        uint8           missionRounds,\r\n        address         creator\r\n    );\r\n    event AuthorizedAddressAdded                (address        indexed addr                                                                        );\r\n    event AuthorizedAddressRemoved              (address        indexed addr                                                                        );\r\n    event MissionFundsRegistered                (uint256                amount,         MissionType indexed missionType,    address indexed sender  );\r\n    event FundsWithdrawn                        (address        indexed to,             uint256             amount                                  );    \r\n    event OwnershipTransferProposed             (address        indexed proposer,       address             newOwner,       uint256 timestamp       );\r\n    event OwnershipTransferConfirmed            (address        indexed confirmer,      address             newOwner,       uint256 timestamp       );\r\n    event MissionStatusUpdated                  (address        indexed mission,        uint8       indexed fromStatus,     uint8   indexed toStatus, uint256        timestamp);\r\n    event MissionFinalized                      (address        indexed mission,        uint8       indexed finalStatus,    uint256 timestamp       );\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Modifiers\r\n    /**\r\n     * @dev Modifier that allows only the owner or an authorized address to call.\r\n     */\r\n    modifier onlyOwnerOrAuthorized() {\r\n        require(\r\n            msg.sender == owner() || authorized[msg.sender],    // Check if the caller is the owner or an authorized address\r\n            \"Not owner or MissionFactory authorized\"\r\n        );\r\n        _;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Modifier that allows only a valid mission contract to call.\r\n     * This ensures that the caller is a contract that has been registered as a mission.\r\n     */\r\n\tmodifier onlyMission() {\r\n        require(\r\n            isMission[msg.sender],                                      // Check if the caller is a registered mission\r\n            \"MissionFactory: caller is not a valid mission contract\"\r\n        );\r\n        _;\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region State Variables\r\n    /**\r\n     * @dev State variables for the MissionFactory contract.\r\n     * These variables store the state of the contract, including authorized addresses, reserved funds, mission statuses, and the implementation address for missions.\r\n     */\r\n    address[]                               public  missions;                                   // Array to hold all mission addresses\r\n    uint8                                   public  weeklyLimit = 7;                            // Maximum number of missions a player can enroll in per week\r\n    uint8                                   public  monthlyLimit = 15;                          // Maximum number of missions a player can enroll in per month\r\n    uint256                                 public  totalMissionFunds;                          // Total funds registered by missions\r\n    uint256                                 public  totalOwnerEarnedFunds;                      // Total funds earned by the owner from missions\r\n    uint256                                 public  totalMissionSuccesses;                      // Total number of successful missions\r\n    uint256                                 public  totalMissionFailures;                       // Total number of failed missions\r\n    address                                 public immutable missionImplementation;             // Address of the Mission implementation contract for creating new missions\r\n    uint256                                 public constant OWNERSHIP_PROPOSAL_WINDOW = 1 days; // Duration for ownership proposal validity\r\n    uint256                                 public proposalTimestamp;                           // The timestamp the proposal was made\r\n    address                                 public proposedNewOwner;                            // The proposed new owner's address     \r\n    address                                 public proposalProposer;                            // The proposer's address\r\n    mapping(address => bool)                public  authorized;                                 // Mapping to track authorized addresses\r\n    mapping(address => bool)                public  isMission;                                  // â†ª quick â€œis this address a mission?â€ lookup\r\n    mapping(address => Status)              public  missionStatus;                              // Mapping to hold the status of each mission\r\n    mapping(MissionType => uint256)         public  reservedFunds;                              // Track funds by type\r\n    mapping(address => uint256[])           private _enrollmentHistory;                         // Store timestamps\r\n    mapping(address => string)              public missionNames;                                // Store mission names\r\n    mapping(MissionType => uint256)         public missionTypeCounts;                           // Store per mission type the mission type count\r\n    mapping(address => uint256)             public lastUserMissionCreatedAt;                    // creator => last creation timestamp\r\n\r\n    // --- Change Tracking (predictable polling; no events) -------------------\r\n    struct ChangeEntry {\r\n        address mission;                                                                        // mission address\r\n        uint40  ts;                                                                             // last touch timestamp (seconds)\r\n        uint64  seq;                                                                            // monotonic change sequence\r\n        uint8   status;                                                                         // factory-known status\r\n    }\r\n\r\n    uint64                                  private _changeSeq;                                 // global increasing sequence\r\n    address[]                               private _changedKeys;                               // each mission appears at most once\r\n    mapping(address => uint32)              private _changedIndexPlus1;                         // 0 = absent, else index + 1\r\n    mapping(address => ChangeEntry)         private _changed;                                   // last change per mission\r\n    uint32                                  private _purgeCursor;                               // rotating cursor for amortized purge\r\n    uint32                                  private constant _PURGE_BATCH_SIZE = 8;             // purge batch size per ended transition\r\n    // -----------------------------------------------------------------------\r\n\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Constructor\r\n    /**\r\n     * @dev Struct to hold information about players who won the mission.\r\n     * Contains the player's address and the amount they won.\r\n     */\r\n    constructor(address _impl) Ownable(msg.sender) {\r\n        require(_impl != address(0), \"impl zero\");\r\n        missionImplementation = _impl;\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Helper functions\r\n    /**\r\n     * @dev Function to convert mission types to human readable names \r\n     */  \r\n    function _toHumanReadableName(MissionType t)                                    internal pure returns (string memory) {\r\n        if (t == MissionType.Hourly)         return \"Hourly\";\r\n        if (t == MissionType.QuarterDaily)   return \"QuarterDaily\";\r\n        if (t == MissionType.BiDaily)        return \"BiDaily\";\r\n        if (t == MissionType.Daily)          return \"Daily\";\r\n        if (t == MissionType.Weekly)         return \"Weekly\";\r\n        if (t == MissionType.Monthly)        return \"Monthly\";\r\n        if (t == MissionType.InviteOnly)     return \"InviteOnly\";\r\n        return \"Custom\";                      \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the time until the next weekly slot for a user.\r\n     * This function calculates the time remaining until the next weekly slot based on the user's enrollment history.\r\n     * @param user The address of the user to check.\r\n     * @return The number of seconds until the next weekly slot.\r\n     */\r\n    function secondsTillWeeklySlot(address user)                                    external view returns (uint256) {\r\n        uint256 nowTs = block.timestamp;                                // Get the current timestamp\r\n        uint256[] storage h = _enrollmentHistory[user];                 // Get the user's enrollment history\r\n        uint256 earliest;                                               // Variable to store the earliest enrollment time within the next week\r\n        for (uint i = 0; i < h.length; i++) {                           // Loop through the enrollment history  \r\n            if (h[i] + 7 days > nowTs) {\r\n                if (earliest == 0 || h[i] < earliest) earliest = h[i];  // If this is the first valid enrollment or earlier than the current earliest, update earliest\r\n            }\r\n        }\r\n        return earliest == 0 ? 0 : earliest + 7 days - nowTs;           // If no valid enrollment found, return 0; otherwise, return the time until the next weekly slot\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the time until the next monthly slot for a user.\r\n     * This function calculates the time remaining until the next monthly slot based on the user's enrollment history.\r\n     * @param user The address of the user to check.\r\n     * @return The number of seconds until the next monthly slot.\r\n     */\r\n    function secondsTillMonthlySlot(address user)                                   external view returns (uint256) {\r\n        uint256 nowTs = block.timestamp;                                // Get the current timestamp\r\n        uint256[] storage h = _enrollmentHistory[user];                 // Get the user's enrollment history\r\n        uint256 earliest;                                               // Variable to store the earliest enrollment time within the next month \r\n        for (uint i = 0; i < h.length; i++) {                           // Loop through the enrollment history  \r\n            if (h[i] + 30 days > nowTs) {\r\n                if (earliest == 0 || h[i] < earliest) earliest = h[i];  // If this is the first valid enrollment or earlier than the current earliest, update earliest\r\n            }\r\n        }\r\n        return earliest == 0 ? 0 : earliest + 30 days - nowTs;   // If no valid enrollment found, return 0; otherwise, return the time until the next monthly slot\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Int. Change Tracking\r\n    function _touchChanged(address mission_, uint8 status_)                         internal {\r\n        unchecked { _changeSeq++; }\r\n        uint32 idxPlus1 = _changedIndexPlus1[mission_];\r\n\r\n        ChangeEntry memory ce = ChangeEntry({\r\n            mission: mission_,\r\n            ts: uint40(block.timestamp),\r\n            seq: _changeSeq,\r\n            status: status_\r\n        });\r\n        _changed[mission_] = ce;\r\n\r\n        if (idxPlus1 == 0) {\r\n            _changedKeys.push(mission_);\r\n            _changedIndexPlus1[mission_] = uint32(_changedKeys.length);\r\n        }\r\n    }\r\n\r\n    function _touchChangedKeepStatus(address mission_)                              internal {\r\n        _touchChanged(mission_, uint8(missionStatus[mission_]));\r\n    }\r\n\r\n    function _isEnded(Status s)                                                     internal pure returns (bool) {\r\n        return (s == Status.Success || s == Status.Failed); // ended = 6,7\r\n    }\r\n\r\n    /// @dev amortized cleanup; scans up to `maxToScan` entries starting at `_purgeCursor`.\r\n    function _purgeEndedBatch(uint32 maxToScan)                                     internal {\r\n        uint256 len = _changedKeys.length;\r\n        if (len == 0) { _purgeCursor = 0; return; }\r\n\r\n        uint32 scanned = 0;\r\n        uint40 cutoff = uint40(block.timestamp - 7 days);\r\n\r\n        while (scanned < maxToScan && _changedKeys.length > 0) {\r\n            if (_purgeCursor >= _changedKeys.length) {\r\n                _purgeCursor = 0;\r\n            }\r\n            address m = _changedKeys[_purgeCursor];\r\n            ChangeEntry memory ce = _changed[m];\r\n\r\n            bool ended = _isEnded(Status(uint8(ce.status)));\r\n            if (ended && ce.ts <= cutoff) {\r\n                uint256 last = _changedKeys.length - 1;\r\n                if (_purgeCursor != last) {\r\n                    address moved = _changedKeys[last];\r\n                    _changedKeys[_purgeCursor] = moved;\r\n                    _changedIndexPlus1[moved] = uint32(_purgeCursor + 1);\r\n                }\r\n                _changedKeys.pop();\r\n                _changedIndexPlus1[m] = 0;\r\n                delete _changed[m];\r\n                // note: keep _purgeCursor at same index to inspect the swapped-in element next\r\n            } else {\r\n                _purgeCursor++;\r\n                scanned++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mission notifies the factory that on-chain state changed (no status change required).\r\n     * @dev Keeps polling predictable without events. Callable only by registered missions.\r\n     */\r\n    function notifyTouched()                                                        external onlyMission {\r\n        _touchChangedKeepStatus(msg.sender);\r\n    }\r\n\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Anti-addiction Func.\r\n    /**\r\n     * @dev Sets the weekly and monthly enrollment limits.\r\n     * This function allows the owner or an authorized address to set the limits for how many missions a user can enroll in per week and per month.\r\n     * @param _weekly The new weekly limit for mission enrollments.\r\n     * @param _monthly The new monthly limit for mission enrollments.\r\n     */\r\n    function setEnrollmentLimits(uint8 _weekly, uint8 _monthly)                     external onlyOwnerOrAuthorized {\r\n        weeklyLimit = _weekly;\r\n        monthlyLimit = _monthly;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a user can enroll in a mission based on anti-addiction limits.\r\n     * This function checks the user's enrollment history to determine if they have exceeded the weekly or monthly limits.\r\n     * @param user The address of the user to check.\r\n     * @return ok A boolean indicating if the user can enroll.\r\n     * @return breach A Limit enum indicating which limit is breached, if any.\r\n     */\r\n    function canEnroll(address user)                                                public view returns (bool ok, Limit breach) {\r\n        uint256 nowTs = block.timestamp;                                    // Get the current timestamp\r\n        uint256 weeklyCount;                                                // Count of enrollments in the last 7 days  \r\n        uint256 monthlyCount;                                               // Count of enrollments in the last 30 days\r\n        uint256 earliest7d;                                                 // Earliest enrollment timestamp in the last 7 days\r\n        uint256 earliest30d;                                                // Earliest enrollment timestamp in the last 30 days    \r\n\r\n        uint256[] storage h = _enrollmentHistory[user];                     // Get the user's enrollment history\r\n        for (uint256 i; i < h.length; ++i) {                                // Loop through the enrollment history\r\n            uint256 t = h[i];\r\n            if (t + 30 days > nowTs) {                                      // If the enrollment is within the last 30 days\r\n                ++monthlyCount;\r\n                if (earliest30d == 0 || t < earliest30d) earliest30d = t;   // Update the earliest enrollment timestamp in the last 30 days\r\n                if (t + 7 days > nowTs) {\r\n                    ++weeklyCount;\r\n                    if (earliest7d == 0 || t < earliest7d) earliest7d = t;  // Update the earliest enrollment timestamp in the last 7 days\r\n                }\r\n            }\r\n        }\r\n\r\n        bool wk = weeklyCount  >= weeklyLimit;                              // Check if the weekly limit is breached    \r\n        bool mo = monthlyCount >= monthlyLimit;                             // Check if the monthly limit is breached\r\n\r\n        if (!wk && !mo) return (true,  Limit.None);                         // If neither limit is breached, return true with Limit.None\r\n\r\n        if (wk && !mo)  return (false, Limit.Weekly);                       // If only the weekly limit is breached, return false with Limit.Weekly\r\n        if (mo && !wk)  return (false, Limit.Monthly);                      // If only the monthly limit is breached, return false with Limit.Monthly   \r\n\r\n        // both breached: compare remaining seconds\r\n        uint256 leftW = earliest7d  +  7 days - nowTs;                      // Calculate the time left until the next weekly slot\r\n        uint256 leftM = earliest30d + 30 days - nowTs;                      // Calculate the time left until the next monthly slot\r\n        return (false, leftM > leftW ? Limit.Monthly : Limit.Weekly);       // If both limits are breached, return the one with the shorter time left\r\n    }\r\n\r\n    /**\r\n     * @dev Records the enrollment of a user in a mission.\r\n     * This function is called when a user enrolls in a mission.\r\n     * It updates the user's enrollment history and emits an event.\r\n     * @param user The address of the user enrolling in the mission.\r\n     */\r\n    function recordEnrollment(address user)                                         external onlyMission() {\r\n        uint256 nowTs = block.timestamp;                                            // Get the current timestamp\r\n        require(missionStatus[msg.sender] == Status.Enrolling);                     // Ensure the caller is in the Enrolling status\r\n\r\n        uint256 cutoff = nowTs - 30 days;                                           // Calculate the cutoff timestamp for pruning  \r\n        uint256[] storage history = _enrollmentHistory[user];                       // Get the user's enrollment history    \r\n        uint256 i = 0;\r\n        while (i < history.length && history[i] < cutoff) {                         // Loop through the history to find entries older than 30 days\r\n            i++;    \r\n        }\r\n        if (i > 0) {                                                                // If there are old entries, remove them\r\n            for (uint256 j = 0; j < history.length - i; j++) {                      // Shift remaining entries to the left\r\n                history[j] = history[j + i];\r\n            }\r\n            for (uint256 k = 0; k < i; k++) {                                       // Remove the last i entries   \r\n                history.pop();\r\n            }\r\n        }\r\n\r\n        history.push(nowTs);                                                        // Add the current timestamp to the enrollment history  \r\n        // touch changed set (status stays the same)\r\n        _touchChangedKeepStatus(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the player's enrollment limits and time until next slots.\r\n     * This function calculates the number of enrollments a player has made in the last week and month,\r\n     * and returns the limits and time until the next slots.\r\n     * @param player The address of the player to check.\r\n     * @return weekUsed The number of enrollments used in the last week.\r\n     * @return weekMax The maximum number of enrollments allowed in a week.\r\n     * @return monthUsed The number of enrollments used in the last month.\r\n     * @return monthMax The maximum number of enrollments allowed in a month.\r\n     * @return secToWeek The number of seconds until the next weekly slot.\r\n     * @return secToMonth The number of seconds until the next monthly slot.\r\n     */\r\n    function getPlayerLimits(address player)                                        external view returns \r\n        (uint8 weekUsed, uint8 weekMax, uint8 monthUsed, uint8 monthMax, uint256 secToWeek, uint256 secToMonth) {\r\n        uint256 nowTs = block.timestamp;                                        // Get the current timestamp\r\n        uint256[] storage h = _enrollmentHistory[player];                       // Get the player's enrollment history\r\n        uint256 weeklyCount;                                                    // Count of enrollments in the last 7 days\r\n        uint256 monthlyCount;                                                   // Count of enrollments in the last 30 days\r\n        uint256 earliest7d;                                                     // Earliest enrollment timestamp in the last 7 days\r\n        uint256 earliest30d;                                                    // Earliest enrollment timestamp in the last 30 days\r\n        for (uint256 i; i < h.length; ++i) {                                    // Loop through the enrollment history\r\n            uint256 t = h[i];\r\n            if (t + 30 days > nowTs) {                                          // If the enrollment is within the last 30 days\r\n                ++monthlyCount;\r\n                if (earliest30d == 0 || t < earliest30d) earliest30d = t;       // Update the earliest enrollment timestamp in the last 30 days\r\n                if (t + 7 days > nowTs) {\r\n                    ++weeklyCount;\r\n                    if (earliest7d == 0 || t < earliest7d) earliest7d = t;      // Update the earliest enrollment timestamp in the last 7 days\r\n                }\r\n            }\r\n        }\r\n        weekUsed   = uint8(weeklyCount);                                        // Convert weekly count to uint8\r\n        weekMax    = weeklyLimit;                                               // Get the maximum weekly limit\r\n        monthUsed  = uint8(monthlyCount);                                       // Convert monthly count to uint8\r\n        monthMax   = monthlyLimit;                                              // Get the maximum monthly limit\r\n        secToWeek  = earliest7d  == 0 ? 0 : earliest7d  + 7 days - nowTs;       // Calculate seconds until next weekly slot\r\n        secToMonth = earliest30d == 0 ? 0 : earliest30d + 30 days - nowTs;      // Calculate seconds until next monthly slot\r\n        return (weekUsed, weekMax, monthUsed, monthMax, secToWeek, secToMonth); // Return the limits and time until next slots\r\n    }\r\n\r\n    /**\r\n     * @dev Undoes a user's enrollment in a mission within a specified time window.\r\n     * This function is called by a mission to remove a user's enrollment record if they are refunded.\r\n     * It searches the user's enrollment history for a timestamp within the specified window and removes it.\r\n     * @param user The address of the user whose enrollment is to be undone.\r\n     * @param startTs The start timestamp of the enrollment window.\r\n     * @param endTs The end timestamp of the enrollment window.\r\n     */\r\n    function undoEnrollmentInWindow(address user, uint256 startTs, uint256 endTs)   external onlyMission {\r\n        uint256[] storage h = _enrollmentHistory[user];\r\n        uint256 len = h.length;\r\n        if (len == 0) return;\r\n\r\n        // Remove exactly one timestamp that falls inside this missionâ€™s enrollment window.\r\n        for (uint256 i = 0; i < len; ++i) {\r\n            uint256 t = h[i];\r\n            if (t >= startTs && t <= endTs) {\r\n                // Keep chronological order (important for pruning logic): shift left, then pop.\r\n                for (uint256 j = i; j + 1 < len; ++j) {\r\n                    h[j] = h[j + 1];\r\n                }\r\n                h.pop();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Admin Functions\r\n    /**\r\n     * @dev Adds an address to the list of authorized addresses.\r\n     * @param account The address to authorize.\r\n     */\r\n    function addAuthorizedAddress(address account)                                  external onlyOwnerOrAuthorized {\r\n        require(account != address(0),  \"addr?\");                                   // Ensure the account is valid\r\n        require(!authorized[account],   \"Already authorized\");                      // Ensure the account is not already authorized\r\n        authorized[account] = true;                                                 // Add authorization for the account  \r\n        emit AuthorizedAddressAdded(account);                                       // Emit event for addition of authorization\r\n    }\r\n\r\n    /**\r\n     * @dev Removes authorization for an address.\r\n     * @param account The address to remove authorization from.\r\n     */\r\n    function removeAuthorizedAddress(address account)                               external onlyOwnerOrAuthorized {\r\n        require(account != address(0),  \"Addr?\");                                   // Ensure the account is valid\r\n        require(authorized[account],    \"!authorized\");                             // Ensure the account is currently authorized\r\n        authorized[account] = false;                                                // Remove authorization for the account\r\n        emit AuthorizedAddressRemoved(account);                                     // Emit event for removal of authorization\r\n    }\r\n\r\n    /**\r\n     * @dev Proposes a transfer of ownership to a new address.\r\n     * @param newOwner The address of the new owner.\r\n     * If the owner is not available anymore or lost access, this function allows an authorized address to propose a new owner.\r\n     */\r\n    function proposeOwnershipTransfer(address newOwner)                             external onlyOwnerOrAuthorized {\r\n        uint256 nowTs = block.timestamp;                                // Get the current timestamp\r\n        require(newOwner != address(0), \"Addr?\");                       // Ensure the new owner is a valid address\r\n        proposedNewOwner = newOwner;\r\n        proposalProposer = msg.sender;\r\n        proposalTimestamp = block.timestamp;\r\n        emit OwnershipTransferProposed(msg.sender, newOwner, nowTs);    // Emit event for ownership transfer proposal\r\n    }\r\n\r\n    /**\r\n     * @dev Confirms the ownership transfer to a new address.\r\n     * This function allows a 2nd authorized address to confirm the ownership transfer.\r\n     */\r\n    function confirmOwnershipTransfer()                                             external onlyOwnerOrAuthorized {\r\n        uint256 nowTs = block.timestamp;                                                                // Get the current timestamp\r\n        require(proposalProposer != msg.sender, \"!Own proposal\");                                       // Ensure the confirmer is not the proposer\r\n        require(block.timestamp <= proposalTimestamp + OWNERSHIP_PROPOSAL_WINDOW, \"Proposal expired\");  // Ensure the proposal is still valid within the proposal window\r\n\r\n        // Transfer ownership\r\n        _transferOwnership(proposedNewOwner);                                                           // Transfer ownership to the new owner   \r\n\r\n        emit OwnershipTransferConfirmed(msg.sender, proposedNewOwner, nowTs);                           // Emit event for ownership transfer confirmation\r\n        // Cleanup\r\n        delete proposedNewOwner;                                                                        // Delete the new owner\r\n        delete proposalProposer;                                                                        // Delete the proposal proposer\r\n        delete proposalTimestamp;                                                                       // Delete the proposal timestamp\r\n\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Core Factory Func.\r\n    /**\r\n     * @dev Creates a new mission with the specified parameters.\r\n     * @param _missionType              The type of the mission.\r\n     * @param _enrollmentStart          The start time for enrollment.\r\n     * @param _enrollmentEnd            The end time for enrollment.\r\n     * @param _enrollmentAmount         The amount required for enrollment.\r\n     * @param _enrollmentMinPlayers     The minimum number of players required to start the mission.\r\n     * @param _enrollmentMaxPlayers     The maxnimum number of players required to start the mission.\r\n     * @param _roundPauseDuration       The duration of pause between rounds in seconds.\r\n     * @param _lastRoundPauseDuration   The duration of pause before the last round in seconds\r\n     * @param _missionStart             The start time for the mission.\r\n     * @param _missionEnd               The end time for the mission.\r\n     * @param _missionRounds            The number of rounds in the mission.\r\n     */\r\n    function createMission (\r\n        MissionType     _missionType,           // Type of the mission\r\n        uint256         _enrollmentStart,       // Start time for enrollment\r\n        uint256         _enrollmentEnd,         // End time for enrollment\r\n        uint256         _enrollmentAmount,      // Amount required for enrollment\r\n        uint8           _enrollmentMinPlayers,  // Minimum number of players required to start the mission\r\n        uint8           _enrollmentMaxPlayers,  // Maximum number of players required to start the mission\r\n        uint8           _roundPauseDuration,    // Duration of pause between rounds in seconds\r\n        uint8           _lastRoundPauseDuration,// Duration of pause before the last round in seconds\r\n        uint256         _missionStart,          // Start time for the mission\r\n        uint256         _missionEnd,            // End time for the mission\r\n        uint8           _missionRounds,         // Number of rounds in the mission\r\n        string calldata _missionName,           // The mission name (optional)\r\n        bytes32         _pinHash,               // The mission pin hash (optional)\r\n        address         _creator                // The user address for UserMission type\r\n        ) external payable onlyOwnerOrAuthorized nonReentrant returns (address, string memory) {\r\n            if (_missionType == MissionType.InviteOnly || _missionType == MissionType.UserMission) {\r\n                // Specified rules for user-created missions\r\n                require(_missionRounds >= 2,                                \"Rounds>1\");                                                        // Ensure mission rounds is at least 2\r\n                require(_enrollmentMinPlayers >= 3,                         \"Min players>2\");                                                   // Ensure minimum players is at least 3\r\n                require(_enrollmentMaxPlayers <= 25,                        \"Max players<26\");                                                  // Ensure maximum players is at most 25\r\n                require(_missionRounds <= _enrollmentMinPlayers - 1,        \"Rounds<=minPlay-1\");                                               // Ensure mission rounds is at most minimum players - 1\r\n                require(_enrollmentAmount >= 1,                             \"Fee>=1\");                                                          // Ensure enrollment amount is at least 1 CRO\r\n                if (_missionType == MissionType.InviteOnly) {\r\n                    require(_pinHash != bytes32(0),                         \"pinHash?\");                                                        // Ensure pin hash is provided\r\n                } else {\r\n                    require(_creator != address(0),                         \"Creator addr?\");                                                   // Ensure user address is provided\r\n                    require(block.timestamp >= lastUserMissionCreatedAt[_creator] + 1 days, \"Min 24h\");                                         // Ensure at least 1 day gap between user mission creations\r\n                }\r\n            } else {\r\n                require(_missionRounds          >= 1,                       \"Mission rnds<1\");                                                  // Ensure mission rounds is greater than or equal to 1\r\n                require(_enrollmentMinPlayers   >= _missionRounds,          \"Min players<mission rnds\");                                        // Ensure minimum players is at least equal to mission rounds\r\n                require(_enrollmentMaxPlayers   >= _enrollmentMinPlayers,   \"Max players<minimum players\");                                     // Ensure maximum players is at least equal to minimum players\r\n                require(_enrollmentMaxPlayers   <= 100,                     \"max players<=100\");                                                // Ensure maximum players is at most 100\r\n            }\r\n            require(_missionStart           >= _enrollmentEnd,              \"M start<enroll end\");                                              // Ensure mission start is on or after enrollment end\r\n            require(_missionEnd             >  _missionStart,               \"M start>=end\");                                                    // Ensure mission start is before end\r\n            require(_roundPauseDuration     >= 60,                          \"Round pause duration<60s\");                                        // Ensure round pause duration is at least 1 minute\r\n            require(_lastRoundPauseDuration >= 60,                          \"Last round pause duration<60s\");                                   // Ensure last round pause duration is at least 1 minute\r\n            require(_enrollmentStart        <  _enrollmentEnd,              \"Enroll start>=end\");                                               // Ensure enrollment start is before end\r\n\t\t\taddress clone = missionImplementation.clone(); \t    // EIP-1167 minimal proxy\r\n\r\n            require(bytes(_missionName).length > 0,                         \"Mission name?\");                                                   // Ensure a mission name is provided\r\n\r\n            isMission[clone]     = true;                        // mark as a valid mission\r\n            missionStatus[clone] = Status.Pending;              // placeholder so first callback passes onlyMission\r\n            missionNames[clone] = _missionName;                 // Store the supplied name\r\n\r\n            Mission(payable(clone)).initialize{value: msg.value} (\r\n\t\t\t\towner(),\t\t\t\t\t\t\t\t\t    // Set the owner of the mission to the owner of MissionFactory\r\n\t\t\t\taddress(this),\t\t\t\t\t\t\t\t    // Set the MissionFactory address\r\n                _missionType,                                   // Set the type of the mission\r\n                _enrollmentStart,                               // Set the enrollment start time\r\n                _enrollmentEnd,                                 // Set the enrollment end time\r\n                _enrollmentAmount,                              // Set the enrollment amount\r\n                _enrollmentMinPlayers,                          // Set the minimum players required\r\n                _enrollmentMaxPlayers,                          // Set the maximum players allowed\r\n                _roundPauseDuration,                            // Set the pause duration between rounds\r\n                _lastRoundPauseDuration,                        // Set the pause duration before the last round\r\n                _missionStart,                                  // Set the mission start time\r\n                _missionEnd,                                    // Set the mission end time\r\n                _missionRounds,                                 // Set the number of rounds in the mission\r\n                _missionName,                                     // The supplied name or calculated name if nothing supplied\r\n                _pinHash,                                       // The mission pin hash (optional)\r\n                _creator                                        // The user address for UserMission type\r\n            );\r\n\r\n        missions.push(clone);                                   // Add the new mission to the list of missions\r\n        emit MissionCreated(\r\n            clone,\r\n            _missionName,\r\n            _missionType,\r\n            _enrollmentStart,\r\n            _enrollmentEnd,\r\n            _enrollmentMinPlayers,\r\n            _enrollmentMaxPlayers,\r\n            _roundPauseDuration,\r\n            _lastRoundPauseDuration,\r\n            _enrollmentAmount,\r\n            _missionStart,\r\n            _missionEnd,\r\n            _missionRounds,\r\n            _creator\r\n        );                                                              // Emit event for mission creation\r\n\r\n        // Calculate allocation based on mission type\r\n        uint256 allocation = reservedFunds[_missionType] / 4;           // Missions get 1/4th of the reserved funds\r\n\r\n        if (allocation > 0 && address(this).balance >= allocation) {\r\n            reservedFunds[_missionType] -= allocation;\r\n            Mission(payable(clone)).increasePot{value: allocation}();   // Sends CRO and updates mission accounting\r\n        }\r\n        if (_missionType == MissionType.UserMission) {\r\n            lastUserMissionCreatedAt[_creator] = block.timestamp;        // Update last creation timestamp for user-created missions\r\n        }\r\n        // initial touch for predictable polling\r\n        _touchChangedKeepStatus(clone);\r\n        return (clone, _missionName);\t\t\t\t\t\t                // Return the address of the newly created mission\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the status of a mission.\r\n     * @param newStatus The new status to set for the mission.\r\n     */\r\n    function setMissionStatus(Status newStatus)                                     external onlyMission {\r\n        Status fromStatus = missionStatus[msg.sender];\r\n        missionStatus[msg.sender] = newStatus;\r\n\r\n        // touch changed set for predictable polling\r\n        _touchChanged(msg.sender, uint8(newStatus));\r\n\r\n        if (newStatus == Status.Success) {\r\n            totalMissionSuccesses++;\r\n        } else if (newStatus == Status.Failed) {\r\n            totalMissionFailures++;\r\n        }\r\n\r\n        emit MissionStatusUpdated(\r\n            msg.sender,\r\n            uint8(fromStatus),\r\n            uint8(newStatus),\r\n            block.timestamp\r\n        );\r\n\r\n        // Ended statuses: PartlySuccess (=5), Success (=6), Failed (=7)\r\n        if (\r\n            newStatus == Status.PartlySuccess ||\r\n            newStatus == Status.Success ||\r\n            newStatus == Status.Failed\r\n        ) {\r\n            // bounded on-the-fly purge only for true ended (6 or 7)\r\n            if (newStatus == Status.Success || newStatus == Status.Failed) {\r\n                _purgeEndedBatch(_PURGE_BATCH_SIZE);\r\n            }\r\n\r\n            emit MissionFinalized(msg.sender, uint8(newStatus), block.timestamp);\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Financial Functions\r\n    /**\r\n     * @dev Registers mission funds for a specific mission type.\r\n     * @param missionType The type of the mission.\r\n     */\r\n    function registerMissionFunds(MissionType missionType)                          external payable onlyMission nonReentrant {\r\n        bool isEndedMission = missionStatus[msg.sender] == Status.Success || missionStatus[msg.sender] == Status.Failed;    // Accept only missions that have ended (Success or Failed)\r\n        require(isEndedMission);                                                                                            // Ensure the caller is a valid mission that has ended \r\n        reservedFunds[missionType] += msg.value;                                                                            // Add the amount to the reserved funds for the specified mission type\r\n        totalMissionFunds += msg.value;                                                                                     // Update the total mission funds\r\n        totalOwnerEarnedFunds += msg.value / 3;                                                                             // Update the total funds earned by the owner (25% of the amount)\r\n        emit MissionFundsRegistered(msg.value, missionType, msg.sender);                                                    // Emit an event for the registered mission funds\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the breakdown of reserved funds for each mission type.\r\n     * This function returns an array containing the reserved funds for each mission type.\r\n     * @return breakdown An array containing the reserved funds for each mission type.\r\n     */\r\n    function reservedFundsBreakdown()                                               external view returns (uint256[9] memory) {\r\n        uint256[9] memory breakdown;                        // Array to hold the breakdown of reserved funds for each mission type\r\n        for (uint256 i = 0; i < 9; i++) {\r\n            breakdown[i] = reservedFunds[MissionType(i)];   // Fill the array with the reserved funds for each mission type\r\n        }\r\n        return breakdown;                                   // Return the breakdown of reserved funds\r\n    }\r\n\r\n    /**\r\n     * @dev Receives funds sent to the contract.\r\n     * This function is called when the contract receives CRO without any data.\r\n     * It allows the contract to accept CRO transfers.\r\n     */\r\n    receive()                                                                       external payable {}\r\n\r\n    /**\r\n     * @dev Fallback function to receive CRO.\r\n     * This function is called when the contract receives CRO without any data.\r\n     * It allows the contract to accept CRO transfers.\r\n     */\r\n    fallback()                                                                      external payable {}\r\n\r\n    /**\r\n     * @dev Withdraws funds from the MissionFactory contract.\r\n     * This function allows the owner or an authorized address to withdraw funds from the contract.\r\n     * This function shall only be called if the contract is not in use anymore and all missions have ended.\r\n     * It transfers the specified amount of funds to the owner of the MissionFactory contract.\r\n     * @param amount The amount of funds to withdraw. If 0, withdraws all available funds.\r\n     */\r\n    function withdrawFunds(uint256 amount)                                          external onlyOwner nonReentrant {\r\n        address mgrOwner = owner();                                         // Get the owner of the MissionFactory contract\r\n        require(mgrOwner != address(0), \"Not owner\");                       // Ensure the manager owner is valid\r\n        if (amount == 0) {\r\n            amount = address(this).balance;                                 // If no amount specified, withdraw all funds\r\n        }\r\n        require(amount <= address(this).balance, \"> balance\");              // Ensure the contract has enough balance to withdraw\r\n        (bool ok, ) = payable(mgrOwner).call{ value: amount }(\"\");          // Attempt to transfer the specified amount to the manager owner\r\n        require(ok, \"TX failed\");                                           // Ensure the transfer was successful\r\n        emit FundsWithdrawn(mgrOwner, amount);                              // Emit event for funds withdrawal\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region View Functions\r\n\r\n    /**\r\n     * @dev Returns the missions a player is participating in and their statuses.\r\n     * This function retrieves all missions the player is enrolled in and their current statuses.\r\n     * @param player The address of the player to check.\r\n     * @return joined An array of addresses of the missions the player is enrolled in.\r\n     * @return statuses An array of statuses corresponding to each mission.\r\n     */\r\n    function getPlayerParticipation(address player)                                 public view returns (address[] memory, Status[] memory, string[] memory) {\r\n        uint256 len = missions.length;                                      // Get the total number of missions\r\n        uint256 count;                                                      // Variable to count how many missions the player is in\r\n\r\n        // First pass: count how many missions the player is in\r\n        for (uint256 i = len; i > 0; i--) {                                 // Loop through the missions from newest to oldest\r\n            if (Mission(payable(missions[i - 1])).isPlayer(player)) {       // Check if the player is enrolled in the mission\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Allocate return arrays\r\n        address[] memory joined     = new address[](count);                 // Create an array to hold the addresses of the missions the player is in\r\n        Status[]  memory statuses   = new Status[](count);                  // Create an array to hold the statuses of the missions the player is in    \r\n        string[]  memory names      = new string[](count);                  // Create an array to hold the mission names\r\n        uint256 idx;                                                        // Index for the return arrays\r\n\r\n        // Second pass: fill both arrays\r\n        for (uint256 i = len; i > 0; i--) {                                 // Loop through the missions from newest to oldest\r\n            address m = missions[i - 1];                                    // Get the address of the current mission\r\n            if (Mission(payable(m)).isPlayer(player)) {                     // Check if the player is enrolled in the mission\r\n                joined[idx]   = m;                                          // Add the mission address to the joined array                          \r\n                statuses[idx] = Mission(payable(m)).getRealtimeStatus();    // Get the realtime status of the mission and add it to the statuses array\r\n                names[idx] = missionNames[m];                               // Add the mission name to the output array\r\n                idx++;                                                      // Increment the index for the return arrays\r\n            }\r\n        }\r\n        return (joined, statuses, names);                                   // Return arrays: addresses of missions not ended, their statuses and names \r\n    }\r\n\r\n    /**\r\n     * @dev Returns a summary of the factory's state.\r\n     * This function returns various details about the factory, including owner address, implementation address, total missions, limits, funds, and mission success/failure counts.\r\n     * @return ownerAddress The address of the owner of the factory.\r\n     * @return factoryAddress The address of the factory contract.\r\n     * @return implementation The address of the mission implementation contract.\r\n     * @return totalMissions The total number of missions created.\r\n     * @return weekly The weekly enrollment limit.\r\n     * @return monthly The monthly enrollment limit.\r\n     * @return missionFunds The total funds registered by missions.\r\n     * @return ownerFunds The total funds earned by the owner from missions.\r\n     * @return successes The total number of successful missions.\r\n     * @return failures The total number of failed missions.\r\n     * @return fundsPerTypeArray An array containing the reserved funds for each mission type (1â€“6).\r\n     */\r\n    function getFactorySummary()                                                    public view\r\n        returns (\r\n            address ownerAddress,\r\n            address factoryAddress,\r\n            address implementation,\r\n            uint256 totalMissions,\r\n            uint256 weekly,\r\n            uint256 monthly,\r\n            uint256 missionFunds,\r\n            uint256 ownerFunds,\r\n            uint256 successes,\r\n            uint256 failures,\r\n            uint256[] memory fundsPerTypeArray\r\n        ) {\r\n        uint256 enumLength = uint256(type(MissionType).max) + 1;\r\n\t\tuint256[] memory breakdown = new uint256[](enumLength);\r\n\t\tfor (uint256 i = 0; i < enumLength; i++) {\r\n\t\t\tbreakdown[i] = reservedFunds[MissionType(i)];\r\n\t\t}\r\n        return (\r\n            owner(),                // Return the address of the owner of the factory contract\r\n            address(this),          // Return the address of the factory contract\r\n            missionImplementation,  // Return the address of the mission implementation contract\r\n            missions.length,        // Return the total number of missions\r\n            weeklyLimit,            // Return the weekly limit\r\n            monthlyLimit,           // Return the weekly and monthly limits\r\n            totalMissionFunds,      // Return the total funds registered by missions\r\n            totalOwnerEarnedFunds,  // Return the total funds registered by missions and earned by the owner\r\n            totalMissionSuccesses,  // Return the total number of successful missions\r\n            totalMissionFailures,   // Return the total number of successful and failed missions\r\n            breakdown               // Return the reserved funds for each mission type\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the status of a mission.\r\n     * @param missionAddress The address of the mission to check.\r\n     * @return mission data of the mission.\r\n     */\r\n    function getMissionData(address missionAddress)                                 external view returns (Mission.MissionData memory) {\r\n        require(missionAddress != address(0), \"Invalid mission address\");          // Ensure mission address is valid\r\n        return Mission(payable(missionAddress)).getMissionData();                           // Return the mission data from the Mission contract\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of missions.\r\n     * This function returns the length of the missions array, which contains all mission addresses.\r\n     * @return The total number of missions.\r\n     */\r\n    function getTotalMissions()                                                     external view returns (uint256) {\r\n        return missions.length;             // Return the total number of missions\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addresses and statuses of all missions.\r\n     * This function retrieves all missions and their statuses, filtering out old missions.\r\n     * @return An array of mission addresses and an array of their corresponding statuses.\r\n     */\r\n    function getAllMissions()                                                       external view returns (address[] memory, Status[] memory, string[] memory) {\r\n        uint256 nowTs = block.timestamp;                                            // Get the current timestamp\r\n        uint256 len = missions.length;\r\n        if (len == 0) {                                                             // If there are no missions, return empty arrays\r\n            return (new address[](0), new Status[](0), new string[](0));\r\n        }\r\n\r\n        uint256 startCutoff = nowTs - 60 days;                                      // skip if missionStart < startCutoff\r\n        uint256 endCutoff   = nowTs - 30 days;                                      // skip if (ended) missionEnd < endCutoff\r\n        uint256 count;\r\n\r\n        // FIRST PASS â”€â”€ count how many to return, scanning newest â†’ oldest\r\n        for (uint256 i = len; i > 0;) {\r\n            unchecked { --i; }                                                      // safe because we check i>0 first\r\n            address m = missions[i];\r\n            Status  s = missionStatus[m];\r\n            Mission.MissionData memory md = Mission(payable(m)).getMissionData();\r\n\r\n            bool tooOld =\r\n                md.missionStart < startCutoff &&                                    // started > 60 days ago\r\n                (s == Status.Success || s == Status.Failed)\r\n                    ? md.missionEnd < endCutoff                                     // â€¦and ended/failed > 30 days ago\r\n                    : md.missionStart < startCutoff;                                // or is still running but started > 60 days ago\r\n\r\n            if (tooOld) {\r\n                break;                                                              // every earlier mission will be older â‡’ stop\r\n            }\r\n            count++;\r\n        }\r\n\r\n        // SECOND PASS â”€â”€ copy the selected missions into fixed-size arrays\r\n        address[] memory outAddrs  = new address[](count);                          // Create an array to hold the addresses of the missions\r\n        Status[]  memory outStatus = new Status[](count);                           // Create an array to hold the statuses of the missions\r\n        string[]  memory names     = new string[](count);                           // Create an array to hold the mission names\r\n        uint256 j;\r\n\r\n        for (uint256 i = len; i > 0 && j < count;) {                                // Loop through the missions from newest to oldest\r\n            unchecked { --i; }\r\n            address m = missions[i];                                                // Get the address of the current mission\r\n            Status  s = missionStatus[m];                                           // Get the status of the current mission    \r\n            Mission.MissionData memory md = Mission(payable(m)).getMissionData();   // Get the mission data for the current mission\r\n\r\n            bool tooOld =\r\n                md.missionStart < startCutoff &&\r\n                (s == Status.Success || s == Status.Failed)                         // If the mission has ended or failed, check if it ended more than 30 days ago\r\n                    ? md.missionEnd < endCutoff\r\n                    : md.missionStart < startCutoff;\r\n\r\n            if (tooOld) {                                                           // If the mission is too old, skip it\r\n                break;\r\n            }\r\n            outAddrs[j]  = m;                                                       // Add the mission address to the output array  \r\n            outStatus[j] = s;                                                       // Add the mission status to the output array\r\n            names[j] = missionNames[m];                                             // Add the mission name to the output array\r\n            unchecked { ++j; }                                                      // Increment the index for the output arrays\r\n        }\r\n\r\n        return (outAddrs, outStatus, names);                                        // Return arrays: addresses of missions not ended, their statuses and names \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addresses of missions filtered by status.\r\n     * This function filters missions based on their status and returns an array of mission addresses that match the specified status.\r\n     * @param s The status to filter missions by.\r\n     * @return An array of mission addresses and an array of their corresponding statuses.\r\n     */\r\n    function getMissionsByStatus(Status s)                                          external view returns (address[] memory, uint8[] memory, string[] memory) {\r\n        uint256 len = missions.length;                              // Get the total number of missions\r\n        uint256 count;\r\n\r\n        // First pass: count missions with the specified status\r\n        for (uint256 i = 0; i < len; i++) {                         // Loop through all missions\r\n            if (missionStatus[missions[i]] == s) {                  // If the mission status matches the specified status\r\n                count++;                                            // Increment the count of matching missions\r\n            }\r\n        }\r\n\r\n        // Second pass: populate result arrays\r\n        address[] memory filteredMissions = new address[](count);   // Create an array to hold the addresses of matching missions\r\n        uint8[]   memory statuses         = new uint8[](count);     // Create a parallel array for statuses\r\n        string[]  memory names            = new string[](count);    // Create an array to hold the mission names\r\n        uint256 index;\r\n        for (uint256 i = 0; i < len; i++) {                         // Loop through all missions again\r\n            if (missionStatus[missions[i]] == s) {                  // If the mission status matches the specified status\r\n                filteredMissions[index] = missions[i];              // Add the mission address to the result array\r\n                statuses[index] = uint8(s);                         // Add the known status\r\n                names[index] = missionNames[missions[i]];           // Add the mission name to the output array\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return (filteredMissions, statuses, names);                 // Return arrays: addresses of missions not ended, their statuses and names \r\n    }\r\n    \r\n    /**\r\n     * @dev Returns the addresses of missions that have not ended.\r\n     * This function filters out missions that are in the Ended or Failed status.\r\n     * @return An array of mission addresses and an array of their corresponding statuses.\r\n     */\r\n    \r\n    function getMissionsNotEnded()                                                  external view returns (address[] memory, uint8[] memory, string[] memory) {\r\n        uint256 len = missions.length;                          // Get the total number of missions \r\n        uint256 count;                                          // Variable to count how many missions are not ended    \r\n\r\n        // First pass: count how many missions are not ended\r\n        for (uint256 i = 0; i < len; i++) {                     // Loop through all missions    \r\n            Status s = missionStatus[missions[i]];\r\n            if (s != Status.Success && s != Status.Failed) {    // If the mission is not in Success or Failed status\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Second pass: populate arrays\r\n        address[] memory result   = new address[](count);       // Create an array to hold the addresses of missions that are not ended\r\n        uint8[]   memory statuses = new uint8[](count);         // Create a parallel array for statuses\r\n        string[]  memory names    = new string[](count);        // Create an array to hold the mission names\r\n        uint256 index;\r\n\r\n        for (uint256 i = 0; i < len; i++) {                     // Loop through all missions again\r\n            Status s = missionStatus[missions[i]];              // Get the status of the current mission\r\n            if (s != Status.Success && s != Status.Failed) {    // If the mission is not in Success or Failed status\r\n                result[index] = missions[i];                    // Add the mission address to the result array\r\n                statuses[index] = uint8(s);                     // Add the status to the statuses array\r\n                names[index] = missionNames[missions[i]];       // Add the mission name to the output array\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return (result, statuses, names);                       // Return arrays: addresses of missions not ended, their statuses and names  \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addresses of missions that have ended.\r\n     * This function filters out missions that are in the Ended or Failed status.\r\n     * @return An array of mission addresses and an array of their corresponding statuses.\r\n     */\r\n    function getMissionsEnded()                                                     external view returns (address[] memory, uint8[] memory, string[] memory) {\r\n        uint256 len = missions.length;                          // Get the total number of missions\r\n        uint256 count;                                          // Variable to count how many missions have ended\r\n\r\n        // First pass: count how many missions are ended\r\n        for (uint256 i = 0; i < len; i++) {                     // Loop through all missions\r\n            Status s = missionStatus[missions[i]];              // Get the status of the current mission\r\n            if (s == Status.Success || s == Status.Failed) {    // If the mission is in Success or Failed status\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Second pass: populate arrays\r\n        address[] memory result   = new address[](count);       // Create an array to hold the addresses of missions that have ended\r\n        uint8[]   memory statuses = new uint8[](count);         // Create a parallel array for statuses\r\n        string[]  memory names    = new string[](count);        // Create an array to hold the mission names\r\n        uint256 index;\r\n\r\n        for (uint256 i = 0; i < len; i++) {                     // Loop through all missions again\r\n            Status s = missionStatus[missions[i]];              // Get the status of the current mission\r\n            if (s == Status.Success || s == Status.Failed) {    // If the mission is in Success or Failed status\r\n                result[index] = missions[i];                    // Add the mission address to the result array  \r\n                statuses[index] = uint8(s);                     // Add the status to the statuses array\r\n                names[index] = missionNames[missions[i]];       // Add the mission name to the output array\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return (result, statuses, names);                       // Return arrays: addresses of missions not ended, their statuses and names  \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addresses of the latest n missions.\r\n     * This function retrieves the last n missions from the list of all missions.\r\n     * @param n The number of latest missions to return.\r\n     * @return An array of mission addresses and an array of their corresponding statuses.\r\n     */\r\n    function getLatestMissions(uint256 n)                                           external view returns (address[] memory, uint8[] memory, string[] memory) {\r\n        uint256 total = missions.length;                    // Get the total number of missions\r\n        if (n > total) n = total;                           // If n is greater than the total number of missions, adjust n to total\r\n\r\n        address[] memory result   = new address[](n);       // Create an array to hold the addresses of the latest missions\r\n        uint8[]   memory statuses = new uint8[](n);         // Create a parallel array for statuses\r\n        string[]  memory names    = new string[](n);        // Create an array to hold the mission names\r\n\r\n        for (uint256 i = 0; i < n; i++) {                   // Loop through the last n missions\r\n            address m = missions[total - 1 - i];            // Get the address of the mission\r\n            result[i] = m;                                  // Add the mission address to the result array  \r\n            statuses[i] = uint8(missionStatus[m]);          // Add the status of the mission to the statuses array\r\n            names[i] = missionNames[m];                     // Add the mission name to the output array\r\n       }\r\n\r\n        return (result, statuses, names);                   // Return arrays: addresses of missions not ended, their statuses and names  \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserved funds for a specific mission type.\r\n     * @param _type The type of the mission to check.\r\n     * @return The amount of reserved funds for the specified mission type.\r\n     */\r\n    function getFundsByType(MissionType _type)                                      external view returns (uint256) {\r\n        return reservedFunds[_type];                                                // Return the reserved funds for the specified mission type\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the proposal data\r\n     * @return newOwner the stored newOwner proposal\r\n     * @return proposer the proposer\r\n     * @return timestamp the time of the proposal\r\n     * @return timeLeft the time left\r\n     */   \r\n    function getOwnershipProposal()                                                 external view returns (address newOwner, address proposer, uint256 timestamp, uint256 timeLeft) {\r\n        if (proposalTimestamp == 0) {\r\n            return (address(0), address(0), 0, 0);                              // No active proposal\r\n        }\r\n\r\n        uint256 expiry = proposalTimestamp + OWNERSHIP_PROPOSAL_WINDOW;\r\n        uint256 nowTs = block.timestamp;\r\n\r\n        if (nowTs >= expiry) {\r\n            return (proposedNewOwner, proposalProposer, proposalTimestamp, 0);  // Expired\r\n        }\r\n\r\n        return (\r\n            proposedNewOwner,\r\n            proposalProposer,\r\n            proposalTimestamp,\r\n            expiry - nowTs                                                      // Seconds remaining until expiry\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns missions changed after `lastSeq`.\r\n     * @dev Pass 0 initially; indexer stores and supplies the last seen sequence.\r\n     */\r\n    function getChangesAfter(uint64 lastSeq)                                        external view returns (address[] memory m, uint40[] memory timestamps, uint64[] memory seqs, uint8[] memory statuses) {\r\n        uint256 n = _changedKeys.length;\r\n\r\n        // count\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            ChangeEntry memory ce = _changed[_changedKeys[i]];\r\n            if (ce.seq > lastSeq) { count++; }\r\n        }\r\n\r\n        m          = new address[](count);\r\n        timestamps = new  uint40[](count);\r\n        seqs       = new  uint64[](count);\r\n        statuses   = new   uint8[](count);\r\n\r\n        // fill\r\n        uint256 w = 0;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            ChangeEntry memory ce = _changed[_changedKeys[i]];\r\n            if (ce.seq > lastSeq) {\r\n                m[w]          = ce.mission;\r\n                timestamps[w] = ce.ts;\r\n                seqs[w]       = ce.seq;\r\n                statuses[w]   = ce.status;\r\n                w++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // #endregion \r\n\r\n    // #endregion\r\n}\r\n\r\n\r\n\r\n\r\n// #region Contract Mission\r\ncontract Mission        is Ownable, ReentrancyGuard {\r\n\r\n\r\n\r\n\r\n    // #region Events\r\n    event MissionStatusChanged  (Status     indexed previousStatus, Status      indexed newStatus,      uint256 timestamp                   );\r\n    event PlayerEnrolled        (address    indexed player,         uint256             amount,         uint256 totalPlayers                );\r\n    event RoundCalled           (address    indexed player,         uint8       indexed roundNumber,    uint256 payout, uint256 croRemaining);\r\n    event PlayerRefunded        (address    indexed player,         uint256             amount                                              );\r\n    event FundsWithdrawn        (uint256            ownerAmount,    uint256             factoryAmount                                       );\r\n    event RefundFailed          (address    indexed player,         uint256             amount                                              ); \r\n    event MissionRefunded       (uint256    indexed nrOfPlayers,    uint256     indexed amount,         address[] player,  uint256 timestamp); // Event emitted when a player is refunded\r\n    event MissionInitialized    (address    indexed owner,          MissionType indexed missionType,    uint256 timestamp                   );\r\n\tevent PotIncreased\t\t\t(uint256\t\t\tvalue,\t\t\tuint256\t\t\t\tcroCurrent\t\t\t\t\t\t\t\t\t\t\t);\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Player custom errors\r\n    error EnrollmentNotStarted(uint256 nowTs, uint256 startTs);     // Enrollment has not started yet.\r\n    error EnrollmentClosed(uint256 nowTs, uint256 endTs);           // Enrollment is closed.\r\n    error MaxPlayers(uint8 maxPlayers);                             // Maximum number of players has been reached.  \r\n    error WrongEntryFee(uint256 expected, uint256 sent);            // The entry fee sent does not match the expected amount.\r\n    error AlreadyJoined();                                          // Player has already joined the mission.\r\n    error WeeklyLimit(uint256 secondsLeft);                         // Weekly  limit for mission enrollments has been reached.\r\n    error MonthlyLimit(uint256 secondsLeft);                        // Monthly limit for mission enrollments has been reached.\r\n    error Cooldown(uint256 secondsLeft);                            // Cooldown period is still active, cannot join a new mission.\r\n    error NotActive(uint256 nowTs, uint256 missionStart);           // Mission is not active yet.\r\n    error MissionEnded();                                           // Mission has already ended.\r\n    error AlreadyWon();                                             // Player has already won in a previous round.\r\n    error NotJoined();                                              // Player has not joined the mission.\r\n    error AllRoundsDone();                                          // All rounds of the mission have been completed.\r\n    error PayoutFailed(address winner, uint256 amount, bytes data); // Payout to a winner failed.\r\n    error ContractsNotAllowed();                                    // Contracts are not allowed to join the mission.\r\n    // #endregion \r\n\r\n\r\n\r\n\r\n\r\n    // #region Modifiers\r\n    /**\r\n     * @dev Modifier to restrict access to the owner or an authorized address.\r\n     * This is used for functions that can only be called by the owner or an authorized address.\r\n     */\r\n    modifier onlyOwnerOrAuthorized() {\r\n        require(\r\n            msg.sender == owner() || missionFactory.authorized(msg.sender),\r\n            \"Not owner or authorized\"\r\n        );\r\n        _;\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Data Structures\r\n    /**\r\n    * @dev Unified per-player record.\r\n    * One record per participant; enriched over the mission lifecycle.\r\n    */\r\n    struct Players {\r\n            address player;         // Player wallet address\r\n            uint256 enrolledTS;     // Timestamp the player enrolled (0 if not set)\r\n            uint256 amountWon;      // Amount won by the player (0 if never won)\r\n            uint256 wonTS;          // Timestamp of the round win (0 if never won)\r\n            bool    refunded;       // True if refund succeeded\r\n            bool    refundFailed;   // True if a refund attempt failed\r\n            uint256 refundTS;       // Timestamp of refund attempt (0 if none)\r\n    }\r\n\r\n    /**\r\n    * @dev Struct to hold all mission data.\r\n    * Contains information about players, mission status, enrollment details, and financials.\r\n    */\r\n    struct MissionData {\r\n            Status          status;                         // Real-time status computed at call time\r\n                    \r\n            uint256         missionCreated;                 // Timestamp of when the mission was created, used for 'Pending' stage in dApp\r\n\r\n            string          name;                           // Name of the mission\r\n            MissionType     missionType;                    // Type of the mission\r\n            uint8           missionRounds;                  // Total number of rounds in the mission\r\n            uint8\t\t\troundPauseDuration;\t\t\t    // Cooldown duration: rounds before the penultimate round\r\n            uint8\t\t\tlastRoundPauseDuration;\t\t    // Cooldown duration: before final round\r\n            uint256         croInitial;                     // Initial CRO amount at the creation of the mission + added by increasePot function\r\n            uint256         croStart;                       // Initial CRO amount at the start of the mission. croInitial + enrollment fee * players\r\n            uint256         croCurrent;                     // Current CRO amount in the mission\r\n            uint256         enrollmentAmount;               // Amount required for enrollment\r\n            uint8           enrollmentMinPlayers;           // Minimum number of players required to start the mission\r\n            uint8           enrollmentMaxPlayers;           // Maximum number of players allowed in the mission\r\n\r\n            uint256         enrollmentStart;                // Start and end times for enrollment\r\n            uint256         enrollmentEnd;                  // Start and end times for enrollment\r\n            uint256         missionStart;                   // Start time for the mission\r\n            uint256         missionEnd;                     // End time for the mission\r\n\r\n            Players[]       players;                        // Unified per-player records (address, timestamps, win/refund info)\r\n            uint8           enrollmentCount;                // Number of players enrolled (non-decreasing)\r\n            uint8           roundCount;                     // Current round count \r\n            uint256         pauseTimestamp;                 // Time when the mission was paused\r\n            bool            allRefunded;                    // True when all enrolled players are refunded and none failed\r\n            address         creator;                        // Address of the mission creator\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region State Variables\r\n    MissionFactory              public  missionFactory;                             // Reference to the MissionFactory contract\r\n    uint256                     public  ownerShare;                                 // Total share of funds for the owner\r\n    uint256                     public  factoryShare;                               // Total share of funds for the MissionFactory\r\n    bool                        public  missionStartConditionChecked;               // Flag to check if the mission start condition has been checked\r\n    MissionData                 private _missionData;                               // Struct to hold all mission data  \r\n    bytes32                     private _enrollSecretHash;                          // Private hash for InviteOnly enrollment verification\r\n    bool                        private _initialized;                               // Flag to track if the contract has been initialized\r\n    Status                      private _previousStatus;                            // Track the previous status of the mission\r\n\r\n    /**\r\n    * @dev Unified per-player records + O(1) index map.\r\n    * `NOT_ENROLLED` sentinel prevents accidental zero-index lookups.\r\n    */\r\n    Players[]                   private _players;                                   // Unified per-player storage (address, timestamps, win/refund info)\r\n    mapping(address => uint8)   private _pIndexPlus1;                               // Address -> (index in _players) + 1 ; 0 means \"not enrolled\"\r\n    uint8                       private constant NOT_ENROLLED = type(uint8).max;    // 255 sentinel for \"not enrolled\"\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Constructor-Initializer\r\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Constructor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    /**\r\n     * @dev Constructor for the Mission contract.\r\n     * Initializes the contract with the owner set to address(0) to prevent accidental ownership.\r\n     * The actual ownership will be set during the initialization phase.\r\n     */\r\n    constructor() Ownable(msg.sender) {}      \r\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Initializer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    /**\r\n     * @dev Initializes the Mission contract.\r\n     * This function sets the initial values for the mission and registers it with the MissionFactory.\r\n     * It can only be called once during contract deployment.\r\n     * @param _owner                The address of the owner of the contract.\r\n     * @param _missionFactory            The address of the MissionFactory contract.\r\n     * @param _missionType          The type of the mission.\r\n     * @param _enrollmentStart      The start time for enrollment.\r\n     * @param _enrollmentEnd        The end time for enrollment.\r\n     * @param _enrollmentAmount     The amount required for enrollment.\r\n     * @param _enrollmentMinPlayers The minimum number of players required to start the mission.\r\n     * @param _enrollmentMaxPlayers The maximum number of players allowed in the mission.\r\n     * @param _missionStart         The start time for the mission.\r\n     * @param _missionEnd           The end time for the mission.\r\n     * @param _missionRounds        The number of rounds in the mission.\r\n     */ \r\n    function initialize(\r\n        address         _owner,\r\n        address         _missionFactory,\r\n        MissionType     _missionType,\r\n        uint256         _enrollmentStart,\r\n        uint256         _enrollmentEnd,\r\n        uint256         _enrollmentAmount,\r\n        uint8           _enrollmentMinPlayers,\r\n        uint8           _enrollmentMaxPlayers,\r\n        uint8           _roundPauseDuration,\r\n        uint8           _lastRoundPauseDuration,\r\n        uint256         _missionStart,\r\n        uint256         _missionEnd,\r\n        uint8           _missionRounds,\r\n        string calldata _name,\r\n        bytes32         _pinHash,\r\n        address         _creator\r\n    )                                                           external payable nonReentrant {\r\n        require(!_initialized, \"Already initialized\");\r\n\r\n        _initialized = true;\r\n\r\n        _transferOwnership(_owner);\r\n        missionFactory = MissionFactory(payable(_missionFactory));\r\n\r\n        // Initialize mission data (unified layout)\r\n        _missionData.missionType             = _missionType;\r\n        _missionData.missionCreated          = block.timestamp;\r\n        _missionData.name                    = _name;\r\n\r\n        _missionData.missionRounds           = _missionRounds;\r\n        _missionData.roundPauseDuration      = _roundPauseDuration;\r\n        _missionData.lastRoundPauseDuration  = _lastRoundPauseDuration;\r\n\r\n        _missionData.croInitial              = msg.value;\r\n        _missionData.croStart                = msg.value;\r\n        _missionData.croCurrent              = msg.value;\r\n\r\n        _missionData.enrollmentAmount        = _enrollmentAmount;\r\n        _missionData.enrollmentMinPlayers    = _enrollmentMinPlayers;\r\n        _missionData.enrollmentMaxPlayers    = _enrollmentMaxPlayers;\r\n\r\n        _missionData.enrollmentStart         = _enrollmentStart;\r\n        _missionData.enrollmentEnd           = _enrollmentEnd;\r\n        _missionData.missionStart            = _missionStart;\r\n        _missionData.missionEnd              = _missionEnd;\r\n\r\n        // Dynamics\r\n        delete _players;                    // clear storage array (fresh clone anyway)\r\n        delete _missionData.players;        // clear storage array (fresh clone anyway)  \r\n        _missionData.enrollmentCount        = 0;\r\n        _missionData.roundCount             = 0;\r\n        _missionData.pauseTimestamp         = 0;\r\n        _missionData.allRefunded            = false;\r\n        _enrollSecretHash                   = _pinHash;\r\n        _missionData.creator                = _creator;\r\n\r\n        emit MissionInitialized(_owner, _missionType, block.timestamp);\r\n    }\r\n\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Core Mission Functions\r\n    /**\r\n    * @notice Allows a player to enroll by paying the enrollment fee.\r\n    * @dev For normal missions. InviteOnly missions must call enrollPlayerWithSecret().\r\n    */\r\n    function enrollPlayer()                                     external payable nonReentrant {\r\n        require(_missionData.missionType != MissionType.InviteOnly, \"InviteOnly: use enrollPlayerWithSecret\");\r\n\r\n        uint256 nowTs = block.timestamp;\r\n        address player = msg.sender;\r\n\r\n        if (player.code.length > 0)                 revert ContractsNotAllowed();\r\n        if (nowTs < _missionData.enrollmentStart)   revert EnrollmentNotStarted(nowTs, _missionData.enrollmentStart);\r\n        if (nowTs > _missionData.enrollmentEnd)     revert EnrollmentClosed(nowTs, _missionData.enrollmentEnd);\r\n\r\n        _enroll(player, nowTs); // shared internal logic\r\n    }\r\n\r\n    /**\r\n    * @dev Enroll for InviteOnly missions using a 4-digit PIN.\r\n    * `salt` is optional but must match what the creator used to build the on-chain hash.\r\n    */\r\n    function enrollPlayerWithSecret(string calldata passphrase) external payable nonReentrant {\r\n        require(_missionData.missionType == MissionType.InviteOnly, \"Not an InviteOnly mission\");\r\n\r\n        // verify hash commitment\r\n        bytes32 h = keccak256(abi.encodePacked(passphrase, _missionData.enrollmentStart));\r\n        require(h == _enrollSecretHash, \"Wrong Secret Passphrase\");\r\n\r\n        uint256 nowTs = block.timestamp;\r\n        address player = msg.sender;\r\n\r\n        if (player.code.length > 0)                 revert ContractsNotAllowed();\r\n        if (nowTs < _missionData.enrollmentStart)   revert EnrollmentNotStarted(nowTs, _missionData.enrollmentStart);\r\n        if (nowTs > _missionData.enrollmentEnd)     revert EnrollmentClosed(nowTs, _missionData.enrollmentEnd);\r\n\r\n        _enroll(player, nowTs); // shared internal logic\r\n    }\r\n\r\n    /**\r\n    * @dev Shared internal enrollment logic used by both enrollPlayer() and enrollPlayerWithSecret().\r\n    */\r\n    function _enroll(address player, uint256 nowTs)             private {\r\n        if (_missionData.enrollmentCount >= _missionData.enrollmentMaxPlayers) {\r\n            revert MaxPlayers(_missionData.enrollmentMaxPlayers);\r\n        }\r\n        if (msg.value != _missionData.enrollmentAmount) {\r\n            revert WrongEntryFee(_missionData.enrollmentAmount, msg.value);\r\n        }\r\n        if (_pIndexPlus1[player] != 0) revert AlreadyJoined();\r\n\r\n        (bool ok, Limit breach) = missionFactory.canEnroll(player);\r\n        if (!ok) {\r\n            if (breach == Limit.Weekly) {\r\n                revert WeeklyLimit(missionFactory.secondsTillWeeklySlot(player));\r\n            } else {\r\n                revert MonthlyLimit(missionFactory.secondsTillMonthlySlot(player));\r\n            }\r\n        }\r\n\r\n        // create per-player record\r\n        _players.push(Players({\r\n            player:         player,\r\n            enrolledTS:     nowTs,\r\n            amountWon:      0,\r\n            wonTS:          0,\r\n            refunded:       false,\r\n            refundFailed:   false,\r\n            refundTS:       0\r\n        }));\r\n        _pIndexPlus1[player] = uint8(_players.length); // store index+1\r\n\r\n        // mirror into mission data for the single-call getter\r\n        Players memory snap = _players[_players.length - 1];\r\n        _missionData.players.push(snap);\r\n        _missionData.enrollmentCount += 1;\r\n\r\n        // funds\r\n        _missionData.croStart   += msg.value;\r\n        _missionData.croCurrent += msg.value;\r\n\r\n        if (_previousStatus != Status.Enrolling) {\r\n            _setStatus(Status.Enrolling);\r\n        }\r\n        missionFactory.recordEnrollment(player);\r\n        emit PlayerEnrolled(player, msg.value, _missionData.enrollmentCount);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the mission's conditions are met to start.\r\n     * Only callable by the owner or an authorized address\r\n     * This function must be called after the enrollment period ends and before the mission starts to\r\n     * refund players if the conditions are not met. If calling the function is obmitted, \r\n     * calling refundPlayers() is the last chance to refund players.\r\n     * @dev If conditions are not met, sets status to Failed and refunds players.\r\n     */\r\n    function checkMissionStartCondition()                       external nonReentrant onlyOwnerOrAuthorized { \r\n        uint256 nowTs = block.timestamp;                                                    // Get the current timestamp\r\n        require(nowTs > _missionData.enrollmentEnd && nowTs < _missionData.missionStart, \r\n                 \"Mission not in arming window. Call refundPlayers instead\");               // Ensure mission is in the correct time window to check start conditions\r\n        require(missionStartConditionChecked == false, \"Already checked start condition\");  // Ensure the start condition has not been checked yet\r\n        missionStartConditionChecked = true;                                                // Set the flag to indicate that the mission start condition has been checked\r\n        if (_missionData.players.length == 0) {                                             // If no players enrolled, set status to Failed and withdraw funds\r\n            _setStatus(Status.Failed);                                                      // Set the mission status to Failed \r\n            _withdrawFunds(true);                                                           // Withdraw funds and refund players\r\n            return;\r\n        }\r\n        if (_missionData.players.length < _missionData.enrollmentMinPlayers) {\r\n            _setStatus(Status.Failed);                                                      // If not enough players, refund and set status to Failed\r\n            _refundPlayers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a player to claim a round reward.\r\n     * @dev A player can only win once. The mission must be Active and not expired.\r\n     * @dev After each round, the mission is Paused for:\r\n     *      - 5 minutes for normal rounds\r\n     *      - 1 minute before the final round\r\n     * @dev Emits {RoundClaimed}.\r\n     * @dev Reverts if:\r\n     *      - Mission is in Cooldown\r\n     *      - Mission is not Active\r\n     *      - Mission has ended\r\n     *      - Player has already won\r\n     *      - Player has not joined\r\n     *      - All rounds have been completed\r\n     *      - Payout to the player fails\r\n     * @dev If it is the last round, sets status to Success and withdraws funds\r\n     */\r\n    function callRound()                                        external nonReentrant {\r\n        Status s = _getRealtimeStatus();\r\n        uint256 nowTs = block.timestamp;\r\n\r\n        if (s == Status.Paused) {\r\n            uint256 cd = (_missionData.roundCount + 1 == _missionData.missionRounds)\r\n                ? _missionData.lastRoundPauseDuration\r\n                : _missionData.roundPauseDuration;\r\n            uint256 secsLeft = _missionData.pauseTimestamp + cd - nowTs;\r\n                                                                    revert Cooldown(secsLeft);\r\n        }\r\n        if (s < Status.Active)                                      revert NotActive(nowTs, _missionData.missionStart);\r\n        if (s > Status.Active)                                      revert MissionEnded();\r\n\r\n        uint8 p1 = _pIndexPlus1[msg.sender];\r\n        if (p1 == 0)                                                revert NotJoined();\r\n        Players storage P = _players[p1 - 1];\r\n        if (P.amountWon > 0 || P.wonTS > 0)                         revert AlreadyWon();\r\n\r\n        if (_missionData.roundCount >= _missionData.missionRounds)  revert AllRoundsDone();\r\n\r\n        uint256 progress = (nowTs - _missionData.missionStart) * 1e10\r\n                        / (_missionData.missionEnd - _missionData.missionStart);\r\n\r\n        uint256 paidSoFar    = _missionData.croStart - _missionData.croCurrent;\r\n        uint256 expectedPaid = (_missionData.croStart * progress) / 1e10;\r\n        require(expectedPaid >= paidSoFar, \"Progress regression\");\r\n\r\n        uint256 payout = expectedPaid - paidSoFar;\r\n        if (payout > _missionData.croCurrent) {\r\n            payout = _missionData.croCurrent;\r\n        }\r\n        require(payout > 0, \"No incremental payout\");\r\n\r\n        // update funds and round\r\n        _missionData.croCurrent -= payout;\r\n        _missionData.roundCount++;\r\n\r\n        // winner info (storage + mirror in getter array)\r\n        P.amountWon = payout;\r\n        P.wonTS     = nowTs;\r\n        _missionData.players[p1 - 1].amountWon = payout;\r\n        _missionData.players[p1 - 1].wonTS     = nowTs;\r\n\r\n        (bool ok, bytes memory data) = msg.sender.call{ value: payout }(\"\");\r\n        if (!ok)                                                    revert PayoutFailed(msg.sender, payout, data);\r\n\r\n        emit RoundCalled(msg.sender, _missionData.roundCount, payout, _missionData.croCurrent);\r\n\r\n        if (_missionData.roundCount == _missionData.missionRounds) {\r\n            _setStatus(Status.Success);\r\n            _withdrawFunds(false);\r\n        } else {\r\n            _setStatus(Status.Paused);\r\n        }\r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region Financial Functions\r\n\t/**\r\n     * @dev Add funds to prize pool.\r\n     */\r\n\tfunction increasePot()                                      external payable {\r\n\t\trequire(msg.value > 0, \"No funds sent\");                                            // Ensure some funds are sent\r\n        require(\r\n            msg.sender == address(missionFactory) || missionFactory.authorized(msg.sender) || msg.sender == owner(),\r\n            \"Only factory or authorized can fund\"\r\n        );                                                                                  // Ensure the sender is the MissionFactory or an authorized address\r\n        require(_getRealtimeStatus() < Status.Active, \"Mission passed activation\");         // Ensure the mission is not already active\r\n        _missionData.croInitial     += msg.value;                                           // Increase the initial CRO amount by the value sent\r\n\t\t_missionData.croStart \t    += msg.value;                                           // Increase the start   CRO amount by the value sent\r\n\t\t_missionData.croCurrent \t+= msg.value;                                           // Increase the current CRO amount by the value sent\r\n\t\temit PotIncreased(msg.value, _missionData.croCurrent);                              // Emit event for pot increase\r\n        // notify factory for predictable polling\r\n        missionFactory.notifyTouched();\r\n\t}\r\n\r\n    /**\r\n     * @dev Refunds players if the mission fails.\r\n     * This function can be called by the owner or an authorized address.\r\n     */\r\n    function refundPlayers()                                    external nonReentrant onlyOwnerOrAuthorized {\r\n        _refundPlayers();                                                                                           // Call internal refund function\r\n    }\r\n\r\n    /**\r\n     * @notice Distributes remaining CRO after mission completion or failure.\r\n     * @dev Sends:\r\n     *      - 25% to factory owner\r\n     *      - 75% to MissionFactory (for future missions)\r\n     * @dev If `force = true`, also withdraws failed refund amounts.\r\n     */\r\n    function withdrawFunds()                                    external nonReentrant onlyOwnerOrAuthorized {\r\n        _withdrawFunds(true);                                                                                     // Call internal withdraw function\r\n        // notify factory for predictable polling\r\n        missionFactory.notifyTouched();\r\n    }\r\n\r\n    /**\r\n     * @notice Allows owner or authorized to finalize a mission after time expiry.\r\n     * @dev Ends mission and withdraws remaining pot.\r\n     */   \r\n    function forceFinalizeMission()                             external onlyOwnerOrAuthorized nonReentrant {\r\n        require(_getRealtimeStatus() == Status.PartlySuccess);  // Ensure mission is in PartlySuccess status\r\n\r\n        _setStatus(Status.Success);                             \r\n        _withdrawFunds(false);                                  // Withdraw funds to MissionFactory contract \r\n    }\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n\r\n    // #region View Functions\r\n\r\n    /**\r\n     * @dev Returns the current number of players enrolled in the mission.\r\n     */\r\n    function getPlayerCount()                                   public view returns (uint256) {\r\n        return _missionData.enrollmentCount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the address is a player in the mission.\r\n     * @param addr The address to check.\r\n     * @return A boolean indicating if the address is a player.\r\n     */\r\n    function isPlayer(address addr)                             public view returns (bool) {\r\n        require(addr != address(0), \"Invalid address\");\r\n        return _pIndexPlus1[addr] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the player state for a given address.\r\n     * This function checks if the player is enrolled and if they have won in any round.\r\n     * @param player The address of the player to check.\r\n     * @return joined A boolean indicating if the player is enrolled in the mission.\r\n     * @return won A boolean indicating if the player has won in any round.\r\n     */\r\n    function playerState(address player)                        external view returns (bool joined, bool won) {\r\n        uint8 p1 = _pIndexPlus1[player];\r\n        if (p1 == 0) return (false, false);\r\n        Players storage p = _players[p1 - 1];\r\n        return (true, (p.amountWon > 0 || p.wonTS > 0));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of seconds until the next round starts.\r\n     * This function checks the current real-time status of the mission and calculates the time until the next round.\r\n     * @return The number of seconds until the next round starts, or 0 if the mission is not paused.\r\n     */\r\n    function secondsUntilNextRound()                            external view returns (uint256) {\r\n        if (_getRealtimeStatus() != Status.Paused) return 0;                        // If the mission is not paused, return 0\r\n        uint256 cd = (_missionData.roundCount + 1 == _missionData.missionRounds)    // Cooldown duration\r\n            ? _missionData.lastRoundPauseDuration                                   \r\n            : _missionData.roundPauseDuration;\r\n        uint256 nowTs = block.timestamp;                                            // Get the current timestamp\r\n        return _missionData.pauseTimestamp + cd - nowTs;                            // Calculate and return the seconds until the next round starts\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current progress percentage of the mission.\r\n     * This function calculates the progress based on the elapsed time since the mission started.\r\n     * @return The current progress percentage of the mission.\r\n     */\r\n    function currentProgressPct()                               external view returns (uint256){\r\n        uint256 nowTs = block.timestamp;                                                                            // Get the current timestamp\r\n        if (nowTs < _missionData.missionStart) {\r\n            return 0;                                                                                               // If the mission has not started, return 0% progress\r\n        }\r\n        if (nowTs >= _missionData.missionEnd) {\r\n            return 100;                                                                                             // If the mission has ended, return 100% progress\r\n        }\r\n        return (nowTs - _missionData.missionStart) * 100 / (_missionData.missionEnd - _missionData.missionStart);   // Calculate progress percentage based on elapsed time\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the pending payout for a player based on their progress in the mission.\r\n     * This function calculates the pending payout based on the current progress percentage and the last payout amount.\r\n     * @param player The address of the player to check for pending payout.\r\n     * @return The pending payout amount for the player, or 0 if not applicable.\r\n     */\r\n    function pendingPayout(address player)                      external view returns (uint256) {\r\n        uint256 nowTs = block.timestamp;\r\n        Status s = _getRealtimeStatus();\r\n        if (s != Status.Active && s != Status.Paused) return 0;\r\n\r\n        uint8 p1 = _pIndexPlus1[player];\r\n        if (p1 == 0) return 0;\r\n        Players storage P = _players[p1 - 1];\r\n        if (P.amountWon > 0 || P.wonTS > 0) return 0;\r\n\r\n        if (nowTs <= _missionData.missionStart || nowTs >= _missionData.missionEnd) return 0;\r\n\r\n        // Expected paid minus paid so far, identical to callRound\r\n        uint256 progress = (nowTs - _missionData.missionStart) * 1e10\r\n                        / (_missionData.missionEnd - _missionData.missionStart);\r\n        uint256 paidSoFar    = _missionData.croStart - _missionData.croCurrent;\r\n        uint256 expectedPaid = (_missionData.croStart * progress) / 1e10;\r\n        if (expectedPaid <= paidSoFar) return 0;\r\n        uint256 payout = expectedPaid - paidSoFar;\r\n        if (payout > _missionData.croCurrent) payout = _missionData.croCurrent;\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of remaining rounds in the mission.\r\n     * This function checks the current real-time status of the mission and returns the number of rounds left.\r\n     * @return The number of remaining rounds in the mission, or 0 if the mission is not in Active or Paused status.\r\n     */\r\n    function remainingRounds()                                  external view returns (uint8) {\r\n        Status s = _getRealtimeStatus();                                        // Get the current real-time status of the mission\r\n        if (s == Status.Active || s == Status.Paused) {\r\n            return _missionData.missionRounds - _missionData.roundCount;        // If the mission is Active or Paused, return remaining rounds\r\n        }\r\n        return 0;                                                               // If the mission is not in Active or Paused status, return 0 remaining rounds\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the MissionData structure.\r\n     */\r\n    function getMissionData()                                   external view returns (MissionData memory) {\r\n            MissionData memory m = _missionData;    // Copy full struct from storage to memory (cheap and compact)\r\n\r\n            m.status = _getRealtimeStatus();        // Patch in real-time status on the memory copy (no storage write)\r\n\r\n            return m;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current real-time status of the mission.\r\n     * This function checks the current time and mission data to determine the status.\r\n     * @return The current status of the mission.\r\n     */\r\n    function getRealtimeStatus()                                external view returns (Status) {\r\n        return _getRealtimeStatus();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the mission is in the arming phase.\r\n     * This function checks if the current time is between the enrollment end and mission start times.\r\n     * @return A boolean indicating if the mission is in the arming phase.\r\n     */\r\n    function isArming()                                         public view returns (bool) {\r\n        uint256 nowTs = block.timestamp;\r\n        return (nowTs > _missionData.enrollmentEnd && nowTs < _missionData.missionStart);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the mission is finalized by realtime status, \r\n            not the status set in the factory which can lag behind.\r\n     * This function checks if the mission is in Success or Failed status.\r\n     * @return A boolean indicating if the mission is finalized.\r\n     */ \r\n    function isFinalized()                                      public view returns (bool) {\r\n        Status s = _getRealtimeStatus();\r\n        return (s == Status.Success || s == Status.Failed);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addresses of players who have failed refunds.\r\n     * This function iterates through all players and collects those with failed refund amounts.\r\n     * @return An array of player addresses who have failed refunds.\r\n     */\r\n    function getFailedRefundPlayers()                           external view returns (address[] memory) {\r\n        require(_getRealtimeStatus() == Status.Failed, \"Mission is not in Failed status\");\r\n        uint256 count;\r\n        for (uint256 i = 0; i < _missionData.players.length; i++) {\r\n            if (_missionData.players[i].refundFailed) count++;\r\n        }\r\n        address[] memory failed = new address[](count);\r\n        uint256 k;\r\n        for (uint256 i = 0; i < _missionData.players.length; i++) {\r\n            if (_missionData.players[i].refundFailed) {\r\n                failed[k++] = _missionData.players[i].player;\r\n            }\r\n        }\r\n        return failed;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a player has been refunded.\r\n     * This function iterates through the refundedPlayers array to check if the address is present.\r\n     * @param addr The address of the player to check for refund status.\r\n     * @return A boolean indicating if the player has been refunded.\r\n     */ \r\n    function wasRefunded(address addr)                          public view returns (bool) {\r\n        require(_getRealtimeStatus() == Status.Failed, \"Mission is not in Failed status\");\r\n        require(addr != address(0), \"Invalid address\");\r\n        uint8 p1 = _pIndexPlus1[addr];\r\n        require(p1 != 0, \"Player not enrolled\");\r\n        return _players[p1 - 1].refunded;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the unified player records for winners (those who have wonTS > 0 or amountWon > 0).\r\n    *      Uses the on-chain unified Players[] model.\r\n    */\r\n    function getWinners()                                       external view returns (Players[] memory) {\r\n        require(\r\n            _getRealtimeStatus() == Status.Success || _getRealtimeStatus() == Status.PartlySuccess,\r\n            \"Mission is not in Success or PartlySuccess status\"\r\n        );\r\n\r\n        // Count winners\r\n        uint256 count;\r\n        for (uint256 i = 0; i < _missionData.players.length; i++) {\r\n            Players memory p = _missionData.players[i];\r\n            if (p.wonTS > 0 || p.amountWon > 0) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Collect winners\r\n        Players[] memory winners = new Players[](count);\r\n        uint256 k;\r\n        for (uint256 i = 0; i < _missionData.players.length; i++) {\r\n            Players memory p = _missionData.players[i];\r\n            if (p.wonTS > 0 || p.amountWon > 0) {\r\n                winners[k++] = p;\r\n            }\r\n        }\r\n\r\n        return winners;\r\n    }\r\n\r\n    /// @notice Lightweight roll-up for indexer reconciliation (rarely used)\r\n    function getIndexerSnapshot()                               external view returns (uint8 status, uint8 roundCount, uint256 croCurrent, uint32 playersCount, uint32 winnersCount, uint32 refundedCount) {\r\n        Status s = _getRealtimeStatus();\r\n\r\n        uint32 winners;\r\n        uint32 refundedN;\r\n        uint256 len = _missionData.players.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            Players memory p = _missionData.players[i];\r\n            if (p.amountWon > 0 || p.wonTS > 0) winners++;\r\n            if (p.refunded) refundedN++;\r\n        }\r\n\r\n        return (\r\n            uint8(s),\r\n            _missionData.roundCount,\r\n            _missionData.croCurrent,\r\n            uint32(_missionData.enrollmentCount),\r\n            winners,\r\n            refundedN\r\n        );\r\n    }\r\n\r\n    /// @notice Return a window of refunded players to avoid huge arrays in one call\r\n    function getRefundedPlayersSlice(uint256 offset, uint256 limit) external view returns (address[] memory slice) {\r\n        // Build a compact list of refunded addresses, then slice\r\n        uint256 len = _missionData.players.length;\r\n        if (len == 0 || limit == 0 || offset >= len) return new address[](0);\r\n\r\n        // Count refunded\r\n        uint256 count;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (_missionData.players[i].refunded) count++;\r\n        }\r\n        if (count == 0) return new address[](0);\r\n\r\n        address[] memory all = new address[](count);\r\n        uint256 k;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (_missionData.players[i].refunded) {\r\n                all[k++] = _missionData.players[i].player;\r\n            }\r\n        }\r\n\r\n        if (offset >= all.length) return new address[](0);\r\n        uint256 to = offset + limit;\r\n        if (to > all.length) to = all.length;\r\n        uint256 n = to - offset;\r\n\r\n        slice = new address[](n);\r\n        for (uint256 i = 0; i < n; i++) {\r\n            slice[i] = all[offset + i];\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n\r\n\r\n\r\n    // #region Internal Helpers\r\n    /**\r\n     * @dev Returns the current status of the mission based on the current time and mission data.\r\n     * This function checks various conditions to determine the real-time status of the mission.\r\n     * @return status The current status of the mission.\r\n     */ \r\n    function _getRealtimeStatus()                               internal view returns (Status status) {\r\n\r\n        // 1. Absolute states never change\r\n        if (_previousStatus == Status.Success || _previousStatus == Status.Failed) {\r\n            return _previousStatus;                                         // mission is already in Success or Failed state, return it\r\n        }\r\n\r\n        uint256 nowTs = block.timestamp;\r\n\r\n        // 2. Before enrollment even opens\r\n        if (nowTs < _missionData.enrollmentStart) {\r\n            return Status.Pending;                                          // mission is not yet open for enrollment\r\n        }\r\n\r\n        // 3. Enrollment window open\r\n        if (nowTs <= _missionData.enrollmentEnd) {\r\n            return Status.Enrolling;                                        // mission is open for enrollment                        \r\n        }\r\n\r\n        // 4. Enrollment closed â€“ decide if we *could* arm\r\n        if (_missionData.players.length < _missionData.enrollmentMinPlayers) {\r\n            return Status.Failed;                                           // not enough players, mission failed   \r\n        }\r\n\r\n        // 5. Waiting for missionStart timestamp\r\n        if (nowTs < _missionData.missionStart) {\r\n            return Status.Arming;                                            // mission is ready to be armed, but not yet started\r\n        }\r\n        \r\n        // 6. Mission active\r\n        if (nowTs < _missionData.missionEnd) {\r\n            if (_missionData.roundCount >= _missionData.missionRounds) {\r\n                return Status.Success;                                      // all rounds completed, mission is successful\r\n            }\r\n            if (_missionData.pauseTimestamp == 0) {\r\n                return Status.Active;                                       // mission is active, no pause in progress\r\n            } else if (nowTs < _missionData.pauseTimestamp +\r\n                ((_missionData.roundCount + 1 == _missionData.missionRounds)\r\n                    ? _missionData.lastRoundPauseDuration\r\n                    : _missionData.roundPauseDuration))\r\n            {\r\n                return Status.Paused;\r\n            }\r\n            else {\r\n                return Status.Active;                                       // mission is active, no pause in progress                   \r\n            }           \r\n        }\r\n        else\r\n        {\r\n            if (_missionData.roundCount == 0) {\r\n                return Status.Failed;                                       // nobody ever called a round â†’ full refund path\r\n            }\r\n            if (_missionData.roundCount < _missionData.missionRounds) {\r\n                return Status.PartlySuccess;                                // some rounds claimed; leftovers need finalization\r\n            }\r\n            return Status.Success;                                          // all rounds claimed\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the status of the mission.\r\n     * @param newStatus The new status to set for the mission.\r\n     */\r\n    function _setStatus(Status newStatus)                       internal {\r\n        uint256 nowTs = block.timestamp;                                // Get the current timestamp\r\n        if (newStatus == Status.Enrolling       ||                      // If the new status is one of these, update the mission status in the MissionFactory\r\n            newStatus == Status.Arming          || \r\n            newStatus == Status.Success         ||\r\n            newStatus == Status.PartlySuccess   ||\r\n            newStatus == Status.Failed) \r\n        {  \r\n            missionFactory.setMissionStatus(newStatus);                 // Update the status in MissionFactory\r\n        }\r\n        if (newStatus == Status.Paused) {\r\n            _missionData.pauseTimestamp = nowTs;                        // Record the time when the mission was paused\r\n        }\r\n        else if (newStatus == Status.Active) {\r\n            _missionData.pauseTimestamp = 0;                            // Reset pause time when the mission is active\r\n        }\r\n        emit MissionStatusChanged(_previousStatus, newStatus, nowTs);   // Emit event for status change\r\n        _previousStatus = newStatus;                                    // Update the previous status to the new status\r\n    }\r\n\r\n    /**\r\n    * @notice Distributes remaining CRO after mission completion or failure.\r\n    * @dev Sends:\r\n    *      - 25% to factory owner\r\n    *      - 75% to MissionFactory (for future missions)\r\n    * @dev If `force = true`, distributes full balance. If `force = false`, keeps aside\r\n    *      the amount needed to cover players whose refunds failed.\r\n    */\r\n    function _withdrawFunds(bool force)                         internal {\r\n        require(_getRealtimeStatus() == Status.Success || _getRealtimeStatus() == Status.Failed);   // Ensure mission is ended\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0,                                \"No funds to withdraw\");                // Ensure there are funds to withdraw\r\n\r\n        if (_missionData.enrollmentCount == 0) {                                                     \r\n            _setStatus(Status.Failed);                                                              // If no players, set status to Failed\r\n        }\r\n\r\n        uint256 distributable;\r\n        if (force) {\r\n            distributable = balance;                                                                // Force: distribute everything\r\n        } else {\r\n            // Compute unclaimable based on unified player model: count refundFailed\r\n            uint256 failedCount;\r\n            for (uint256 i = 0; i < _missionData.players.length; i++) {\r\n                if (_missionData.players[i].refundFailed) {\r\n                    unchecked { failedCount++; }\r\n                }\r\n            }\r\n            uint256 unclaimable = failedCount * _missionData.enrollmentAmount;                      // Reserve for retriable refunds\r\n            if (unclaimable > balance) unclaimable = balance;                                       // Safety clamp\r\n            distributable = balance - unclaimable;\r\n        }\r\n\r\n        require(distributable > 0,                          \"No funds to withdraw\");          // Ensure there are funds to withdraw after deductions\r\n\r\n        uint256 _ownerShare;\r\n        uint256 _factoryShare;\r\n\r\n        // For InviteOnly missions, send 100% of leftover to the owner; nothing flows back to the factory.\r\n        if (_missionData.missionType == MissionType.InviteOnly) {\r\n            _ownerShare   = distributable;\r\n            _factoryShare = 0;\r\n\r\n            (bool okInvite, ) = payable(missionFactory.owner()).call{value: _ownerShare}(\"\");\r\n            require(okInvite,                                \"Owner payout failed\");\r\n\r\n            emit FundsWithdrawn(_ownerShare, _factoryShare);\r\n            ownerShare   = _ownerShare;\r\n            factoryShare = _factoryShare;\r\n            return;\r\n        } else if (_missionData.missionType == MissionType.UserMission) {\r\n            // For PublicWithCreator missions, send 50% to the mission creator and 50% to the factory owner;\r\n            _ownerShare   = (distributable * 50) / 100;\r\n            uint256 creatorShare = distributable - _ownerShare;\r\n            _factoryShare = 0;\r\n\r\n            (bool okOwner, ) = payable(missionFactory.owner()).call{value: _ownerShare}(\"\");\r\n            require(okOwner,                                 \"Owner payout failed\");\r\n\r\n            (bool okCreator, ) = payable(_missionData.creator).call{value: creatorShare}(\"\");\r\n            require(okCreator,                               \"Creator payout failed\");\r\n\r\n            emit FundsWithdrawn(_ownerShare + creatorShare, _factoryShare);\r\n            ownerShare   = _ownerShare + creatorShare;\r\n            factoryShare = _factoryShare;\r\n            return;\r\n        }\r\n\r\n        // Default behavior for other mission types: 25% owner / 75% factory\r\n        _ownerShare   = (distributable * 25) / 100;\r\n        _factoryShare = distributable - _ownerShare;\r\n\r\n        (bool ok, ) = payable(missionFactory.owner()).call{value: _ownerShare}(\"\");\r\n        require(ok,                                         \"Owner payout failed\");\r\n\r\n        missionFactory.registerMissionFunds{ value: _factoryShare }(\r\n            _missionData.missionType\r\n        );\r\n\r\n        emit FundsWithdrawn(_ownerShare, _factoryShare);\r\n        ownerShare   = _ownerShare;\r\n        factoryShare = _factoryShare;\r\n\r\n        _missionData.croCurrent = address(this).balance;                                            // Current balance after distribution\r\n    }\r\n\r\n    /**\r\n     * @dev Refunds players if the mission fails.\r\n     * This function is internal and can only be called when the mission is in Failed status.\r\n     * It ensures that the mission has ended and that the enrollment period has passed.\r\n     * It refunds all enrolled players their enrollment amount.\r\n     */\r\n    function _refundPlayers()                                   internal {\r\n        require(_getRealtimeStatus() == Status.Failed, \"Mission not in Failed status\");\r\n        require(_missionData.enrollmentCount > 0,      \"No players to refund\");\r\n\r\n        bool forceAll = true;\r\n        uint256 nowTs = block.timestamp;\r\n\r\n        for (uint256 i = 0; i < _players.length; i++) {\r\n            Players storage P = _players[i];\r\n\r\n            // Retry any player who is not yet refunded (even if a previous attempt failed)\r\n            if (!P.refunded) {\r\n                (bool ok, ) = payable(P.player).call{ value: _missionData.enrollmentAmount }(\"\");\r\n                if (ok) {\r\n                    // Success: mark refunded and CLEAR refundFailed (in case a prior attempt failed)\r\n                    P.refunded     = true;\r\n                    P.refundFailed = false;\r\n                    P.refundTS     = nowTs;\r\n\r\n                    // Mirror to MissionData.players (same index)\r\n                    _missionData.players[i].refunded     = true;\r\n                    _missionData.players[i].refundFailed = false;\r\n                    _missionData.players[i].refundTS     = nowTs;\r\n\r\n                    emit PlayerRefunded(P.player, _missionData.enrollmentAmount);\r\n\r\n                    missionFactory.undoEnrollmentInWindow(\r\n                        P.player,\r\n                        _missionData.enrollmentStart,\r\n                        _missionData.enrollmentEnd\r\n                    );\r\n                } else {\r\n                    // Failure: set/keep failed flag\r\n                    P.refundFailed = true;\r\n                    P.refundTS     = nowTs;\r\n                    _missionData.players[i].refundFailed = true;\r\n                    _missionData.players[i].refundTS     = nowTs;\r\n\r\n                    emit RefundFailed(P.player, _missionData.enrollmentAmount);\r\n                    forceAll = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update allRefunded flag (true only if every enrolled player is refunded and none failed)\r\n        bool allOk = true;\r\n        for (uint256 i = 0; i < _players.length; i++) {\r\n            if (!_players[i].refunded)        { allOk = false; break; }\r\n            if (_players[i].refundFailed)     { allOk = false; break; }\r\n        }\r\n        _missionData.allRefunded = allOk;\r\n\r\n        _setStatus(Status.Failed);\r\n\r\n        if (address(this).balance > 0) {\r\n            _withdrawFunds(forceAll);\r\n        }\r\n\r\n        // Build refunded list snapshot (addresses) for the event payload\r\n        uint256 count;\r\n        for (uint256 i = 0; i < _players.length; i++) if (_players[i].refunded) count++;\r\n        address[] memory refundedAddrs = new address[](count);\r\n        uint256 k;\r\n        for (uint256 i = 0; i < _players.length; i++) if (_players[i].refunded) refundedAddrs[k++] = _players[i].player;\r\n\r\n        emit MissionRefunded(\r\n            count,\r\n            _missionData.enrollmentAmount,\r\n            refundedAddrs,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #endregion\r\n}\r\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"viaIR":true,"evmVersion":"paris","outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"],"":["ast"]}}}}