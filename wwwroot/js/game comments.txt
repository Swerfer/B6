Pending (0) — “no pill updates, except counters (frontend)”

What updates: just countdown/clock visuals.

Where it happens: bindCenterTimerToMission() → startStageTimer() ticks once per second and updates (a) the center short timer and (b) any pill texts that have a data-countdown attribute (it loops #stageLowerHud [data-countdown] and formats them). For Pending, your lower-HUD set doesn’t include countdown pills, but the center clock still ticks.

Deadline chosen: nextDeadlineFor(m) returns enrollment_start in Pending; that’s what the timer binds to.

Pending → Enrolling (1) — immediate flip when timer hits 0

Trigger: startStageTimer() detects left <= 0. It computes the next status via statusByClock() and flips the stage immediately on the frontend.

Pills: because next is 1, it does not paint from API—it calls await rehydratePillsFromChain(m2, "deadlineFlip") so Players and Pool (current) come straight from chain truth.

Then: it binds ring, center timer, CTA, ended panel (if needed) and sets stageCurrentStatus. A reconcile run (refreshOpenStageFromServer(2)) follows to let API denorms catch up.

Enrolling (1) — counters + Players + Pool (current)

These update via four paths:

Initial open of the stage:
showGameStage(...) detects status 1 and calls await rehydratePillsFromChain(mission, "openStage") (no API overwrite).

User joins (joiner sees instant change):

handleEnrollClick(...) sets a short optimisticGuard window and immediately paints pills with players+1 and poolNow on the UI.

A delayed refreshOpenStageFromServer(2) reconciles from the API but your refresh path now routes Enrolling through await rehydratePillsFromChain(m,"serverRefresh"), so API can’t regress the numbers.

Everyone else (spectators) via real-time pushes:

StatusChanged (e.g., flip into 1): builds the stage, then for 1/2 does await rehydratePillsFromChain(mLocal,"statusChanged").

MissionUpdated (any payload change during 1): both “moved forward” and “same status” branches call await rehydratePillsFromChain(...) for 1/2, then schedule a gentle reconcile.

Scheduled server reconcile while on stage:
refreshOpenStageFromServer(...) detects 1/2 and again uses await rehydratePillsFromChain(...) instead of painting from API first.

The chain hydrator itself:

Reads players from getMissionData(), derives cro_current_wei = cro_start_wei + fee * players, caches last chain numbers (__lastChainPlayers, __lastChainCroWei), and calls buildStageLowerHudForStatus(merged).

Every paint calls applyChainNoRegress(...) inside buildStageLowerHudForStatus(...), so stale API snapshots can’t overwrite those two numbers.

Countdown pill Closes In ticks once/second via startStageTimer() updating [data-countdown].

Enrolling → Arming (2) — immediate flip at enrollment end

Trigger: same startStageTimer() zero-hit path; statusByClock() returns 2 or 7 (Failed) based on min players.

Pills: because next is 2, it again rehydrates from chain before drawing, then rebinds everything. Reconcile follows.

Arming (2) — “no updates besides timers”

What updates: the Starts In countdown pill and ring/center clock tick via startStageTimer(); lower-HUD pills include startsIn and static values (players/rounds/poolStart).

Note: your paint paths still use chain in 2 (StatusChanged/MissionUpdated/refresh), but values here don’t change anymore, so it’s effectively a stable repaint plus the countdown.

Arming → Mission Time (3) — immediate flip at mission start

Trigger: startStageTimer() zero-hit → statusByClock() yields 3.

Pills: for 3 it does not call the chain hydrator— it paints lower HUD directly (buildStageLowerHudForStatus(m2)), then rebinds ring/timer/CTA and sets status. Reconcile follows.

Mission Time (3) — Pool (current) & Rounds + timers

Rounds and Pool (pills):

MissionUpdated push (from backend after a round) → for “same status” it rebuilds lower HUD from the fresh API snapshot (not chain) and refreshes CTA, then schedules a reconcile.

RoundResult push → shows the inline banner and then calls refreshOpenStageFromServer(2) (which paints directly for status 3).

Manual action (“Bank it!”) → after tx and any win-wait, it calls refreshOpenStageFromServer(2).

Timers/labels (frontend):

The “Ends in …” pill/value uses data-countdown and is updated each second in startStageTimer();

The CTA’s “Bank this round to claim:”/“Current round prize pool:” line updates live via [data-bank-now] using computeBankNowWei(...) every tick (this is not a pill, it’s the CTA line).

Mission Time → Ended (5/6/7) — by backend or at timer

Timer path: startStageTimer() zero-hit flips front-end immediately to ended, repaints HUD, ring, CTA, ended panel, and sets stageCurrentStatus, then reconciles.

Backend push path: StatusChanged/MissionUpdated handlers rebuild the stage for the new ended status and paint pills immediately.

Ended (5/6/7) — one-time refresh of Pool (current) and Rounds N/N

Pills: ended states go through the normal HUD paint (default pill set includes Pool (current) and Rounds N/N). These are taken from the API snapshot on each paint (no chain hydrate in ended).

Ended panel: renderStageEndedPanelIfNeeded(m) fetches enrollments/rounds once and renders “Top winners” (Failed 7 shows reason). This is called whenever we paint an ended status, typically first flip + maybe one reconcile.

“Will both the joiner/banker and everyone else see it?”

Joining: the joiner gets an instant optimistic pill update in handleEnrollClick(...); others get the change via MissionUpdated push and the periodic refreshOpenStageFromServer(...) that defers to chain hydrate in 1/2. No regressions thanks to applyChainNoRegress(...).

Banking: after a round is called, everyone on stage gets a RoundResult push → stage notice + refreshOpenStageFromServer(2). If your wallet won, you also get the success alert immediately.